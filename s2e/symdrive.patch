From b8fae732a27de42bfa7623e8247fb8d02bd68a3b Mon Sep 17 00:00:00 2001
From: Matt Renzelmann <mjr@cs.wisc.edu>
Date: Mon, 15 Oct 2012 13:44:02 -0500
Subject: [PATCH] SymDrive 1.0


Signed-off-by: Matt Renzelmann <mjr@cs.wisc.edu>
---
 Makefile                                           |    4 +-
 README_SYMDRIVE                                    |    1 +
 guest/include/s2e.h                                |  437 +++-
 klee/lib/Core/AddressSpace.cpp                     |   36 +
 klee/lib/Core/AddressSpace.h                       |    3 +
 qemu/Makefile.target                               |    4 +
 qemu/configure                                     |    2 +-
 qemu/exec.c                                        |   33 +
 qemu/hw/fakepci.c                                  |   86 +-
 qemu/hw/fakepci.h                                  |    4 +
 qemu/hw/pci.c                                      |   18 +
 qemu/llvm-lib.h                                    |   11 +-
 qemu/qemu-options.hx                               |    9 +
 qemu/s2e/MMUFunctionHandlers.cpp                   |   85 +-
 qemu/s2e/Plugins/BaseInstructions.cpp              |   58 +-
 qemu/s2e/Plugins/CorePlugin.cpp                    |  117 +
 qemu/s2e/Plugins/CorePlugin.h                      |   29 +
 .../Plugins/ExecutionTracers/ExecutionTracer.cpp   |    4 +-
 qemu/s2e/Plugins/ExecutionTracers/TraceEntries.h   |   71 +
 qemu/s2e/Plugins/ModuleDescriptor.h                |    2 +
 qemu/s2e/Plugins/RawMonitor.cpp                    |    9 +
 qemu/s2e/Plugins/RawMonitor.h                      |    2 +
 qemu/s2e/Plugins/SymDrive/MCoverageBasics.h        |   66 +
 qemu/s2e/Plugins/SymDrive/SymDriveSearcher.cpp     | 3035 ++++++++++++++++++++
 qemu/s2e/Plugins/SymDrive/SymDriveSearcher.h       |  409 +++
 .../SymDrive/SymDriveTranslationBlockTracer.cpp    |  193 ++
 .../SymDrive/SymDriveTranslationBlockTracer.h      |  103 +
 qemu/s2e/Plugins/SymbolicHardware.cpp              |  297 ++-
 qemu/s2e/Plugins/SymbolicHardware.h                |    9 +
 qemu/s2e/S2E.cpp                                   |    4 +-
 qemu/s2e/S2E.h                                     |    1 +
 qemu/s2e/S2EExecutionState.cpp                     |    2 +
 qemu/s2e/S2EExecutor.cpp                           |  156 +-
 qemu/s2e/S2EExecutor.h                             |   29 +-
 qemu/s2e/s2e_qemu.h                                |   13 +-
 qemu/softmmu_defs.h                                |    3 +-
 qemu/softmmu_header.h                              |    6 +-
 qemu/softmmu_template.h                            |  423 ++--
 qemu/target-i386/op_helper.c                       |  203 +-
 qemu/tcg/tcg-llvm.cpp                              |    6 +-
 qemu/vl.c                                          |    9 +
 41 files changed, 5574 insertions(+), 418 deletions(-)
 create mode 100644 README_SYMDRIVE
 create mode 100644 qemu/s2e/Plugins/SymDrive/MCoverageBasics.h
 create mode 100644 qemu/s2e/Plugins/SymDrive/SymDriveSearcher.cpp
 create mode 100644 qemu/s2e/Plugins/SymDrive/SymDriveSearcher.h
 create mode 100644 qemu/s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.cpp
 create mode 100644 qemu/s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.h

diff --git a/Makefile b/Makefile
index cf354b9..ecd611f 100644
--- a/Makefile
+++ b/Makefile
@@ -1,3 +1,5 @@
+# MJR search for "mjr" to find changes
+
 S2ESRC:=$(CURDIR)/../s2e
 S2EBUILD:=$(CURDIR)
 
@@ -12,7 +14,7 @@ else ifeq ($(OS),Linux)
 JOBS := $(shell grep -c ^processor /proc/cpuinfo)
 endif
 
-all: all-release
+all: all-release all-debug # MJR do both simultaneously
 
 all-release: stamps/qemu-make-release stamps/tools-make-release
 
diff --git a/README_SYMDRIVE b/README_SYMDRIVE
new file mode 100644
index 0000000..ac7d4b6
--- /dev/null
+++ b/README_SYMDRIVE
@@ -0,0 +1 @@
+This version of SymDrive is based on S2E version b5cfd33051c3be3ab254a5d3e9f4376861188c77
diff --git a/guest/include/s2e.h b/guest/include/s2e.h
index 0d37449..0a82786 100644
--- a/guest/include/s2e.h
+++ b/guest/include/s2e.h
@@ -34,21 +34,29 @@
  *
  */
 
-#include <stdio.h>
-#include <string.h>
-#include <inttypes.h>
+#ifndef S2E_MAIN_HEADER_H // MJR
+#define S2E_MAIN_HEADER_H // MJR
+
+//#include <stdio.h> // MJR
+//#include <string.h> // MJR
+//#include <inttypes.h> // MJR
+
+// MJR:
+#define ALWAYS_INLINE static __attribute__((always_inline)) inline
+// #define ALWAYS_INLINE __attribute__((always_inline))
+// #define ALWAYS_INLINE inline
 
 /** Forces the read of every byte of the specified string.
   * This makes sure the memory pages occupied by the string are paged in
   * before passing them to S2E, which can't page in memory by itself. */
-static inline void __s2e_touch_string(volatile const char *string)
+ALWAYS_INLINE void __s2e_touch_string(volatile const char *string)
 {
     while(*string) {
         ++string;
     }
 }
 
-static inline void __s2e_touch_buffer(volatile void *buffer, unsigned size)
+ALWAYS_INLINE void __s2e_touch_buffer(volatile void *buffer, unsigned size)
 {
     unsigned i;
     volatile char *b = (volatile char *)buffer;
@@ -58,7 +66,7 @@ static inline void __s2e_touch_buffer(volatile void *buffer, unsigned size)
 }
 
 /** Get S2E version or 0 when running without S2E. */
-static inline int s2e_version()
+ALWAYS_INLINE int s2e_version(void) // MJR
 {
     int version;
     __asm__ __volatile__(
@@ -71,7 +79,7 @@ static inline int s2e_version()
 }
 
 /** Print message to the S2E log. */
-static inline void s2e_message(const char* message)
+ALWAYS_INLINE void s2e_message(const char* message)
 {
     __s2e_touch_string(message);
     __asm__ __volatile__(
@@ -83,7 +91,7 @@ static inline void s2e_message(const char* message)
 }
 
 /** Print warning to the S2E log and S2E stdout. */
-static inline void s2e_warning(const char* message)
+ALWAYS_INLINE void s2e_warning(const char* message)
 {
     __s2e_touch_string(message);
     __asm__ __volatile__(
@@ -95,7 +103,7 @@ static inline void s2e_warning(const char* message)
 }
 
 /** Print symbolic expression to the S2E log. */
-static inline void s2e_print_expression(const char* name, int expression)
+ALWAYS_INLINE void s2e_print_expression(const char* name, int expression)
 {
     __s2e_touch_string(name);
     __asm__ __volatile__(
@@ -107,7 +115,7 @@ static inline void s2e_print_expression(const char* name, int expression)
 }
 
 /** Enable forking on symbolic conditions. */
-static inline void s2e_enable_forking(void)
+ALWAYS_INLINE void s2e_enable_forking(void)
 {
     __asm__ __volatile__(
         ".byte 0x0f, 0x3f\n"
@@ -117,7 +125,7 @@ static inline void s2e_enable_forking(void)
 }
 
 /** Disable forking on symbolic conditions. */
-static inline void s2e_disable_forking(void)
+ALWAYS_INLINE void s2e_disable_forking(void)
 {
     __asm__ __volatile__(
         ".byte 0x0f, 0x3f\n"
@@ -137,7 +145,7 @@ static inline void s2e_yield(void)
 }
 
 /** Get the current execution path/state id. */
-static inline unsigned s2e_get_path_id(void)
+ALWAYS_INLINE unsigned s2e_get_path_id(void)
 {
     unsigned id;
     __asm__ __volatile__(
@@ -150,7 +158,7 @@ static inline unsigned s2e_get_path_id(void)
 }
 
 /** Fill buffer with unconstrained symbolic values. */
-static inline void s2e_make_symbolic(void* buf, int size, const char* name)
+ALWAYS_INLINE void s2e_make_symbolic(void* buf, int size, const char* name)
 {
     __s2e_touch_string(name);
     __s2e_touch_buffer(buf, size);
@@ -165,8 +173,315 @@ static inline void s2e_make_symbolic(void* buf, int size, const char* name)
     );
 }
 
+////////////////// MJR -------------------------------------------->
+// MJR 23 in all.
+
+/** Fill buffer with unconstrained symbolic values. */
+/** Equivalent to I/O memory:  writes are discarded */
+/* MJR added this, requires SymbolicHardware */
+ALWAYS_INLINE void s2e_make_dma_symbolic(void* buf, int size, const char* name)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xB1, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (buf), "b" (size), "c" (name) : "memory"
+                         );
+}
+
+/** Remove symbolic mapping. */
+/* Does not leave memory as symbolic afterward. Reads revert to underlying concrete value */
+/* MJR added this, requires SymbolicHardware */
+ALWAYS_INLINE void s2e_free_dma_symbolic(void* buf, int size, const char* name)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xB2, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (buf), "b" (size), "c" (name) : "memory"
+                         );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_prioritize(int line)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xB3, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line)
+                         );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_deprioritize(int line)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xB4, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line)
+                         );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_loop_before(int line, int call_id)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xB5, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (call_id)
+                         );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_loop_body(int line, int call_id)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xB6, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (call_id)
+                         );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_loop_after(int line, int call_id)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xB7, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (call_id)
+                         );
+}
+
+// MJR Added this, requires SymDriveSearcher
+ALWAYS_INLINE void s2e_concretize_kill(int line)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xB8, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line)
+                         );
+}
+
+ALWAYS_INLINE void s2e_concretize_all(int line) {
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xB9, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line)
+                         );
+}
+
+ALWAYS_INLINE void s2e_kill_all_others(int line) {
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xBA, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line)
+                         );
+}
+
+// MJR Added this, requires SymDriveSearcher
+ALWAYS_INLINE void s2e_driver_call_stack(int line, int depth)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xBB, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (depth)
+                         );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_favor_successful(int line, int successful)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xBC, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (successful)
+                         );
+}
+
+// MJR opcode hole
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_reset_priorities(int line)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xBE, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line)
+                         );
+}
+
+// MJR opcode hole
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_enable_tracing(int line)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC0, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line)
+    );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_disable_tracing(int line)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC1, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line)
+    );
+}
+
+// MJR added this, requires SymDriveSearcher...
+/** Notify S2E that we've entered a driver function. */
+ALWAYS_INLINE void s2e_enter_function(int line, const char* message, int wrapper_type)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC2, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (message), "c" (wrapper_type)
+    );
+}
+
+// MJR added this, requires SymDriveSearcher...
+/** Notify S2E that we've exited a driver function. */
+ALWAYS_INLINE void s2e_exit_function(int line, const char* message, int wrapper_type)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC3, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (message), "c" (wrapper_type)
+    );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE int s2e_is_symbolic_symdrive(int line, int expr)
+{
+    int retval;
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC4, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : "=a" (retval)  : "a" (line), "b" (expr)
+    );
+    return retval;
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_success_path(int line, int success)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC5, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (success)
+    );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_enter_block(int line, const char *fn, int total_blocks, int cur_block)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC6, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (fn), "c" (total_blocks), "d" (cur_block)
+    );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_primary_fn(int line, const char *fn)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC7, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (fn)
+                         );
+}
+
+// If changing this:
+// Update SymDriveSearcher.h
+// Update MJR_dump_trackperf function
+// Update MTbTrace
+#define SYMDRIVE_PAUSE_PP 11
+#define SYMDRIVE_CONTINUE_PP 12
+
+#define SYMDRIVE_PAUSE_STUB 21
+#define SYMDRIVE_CONTINUE_STUB 22
+
+#define SYMDRIVE_PAUSE_IRQ 31
+#define SYMDRIVE_CONTINUE_IRQ 32
+
+#define SYMDRIVE_START_AUTO 40
+#define SYMDRIVE_PAUSE_AUTO 41
+#define SYMDRIVE_CONTINUE_AUTO 42
+#define SYMDRIVE_STOP_AUTO 43
+#define SYMDRIVE_DISCARD_AUTO 44
+
+#define SYMDRIVE_START_MANUAL 50
+#define SYMDRIVE_PAUSE_MANUAL 51
+#define SYMDRIVE_CONTINUE_MANUAL 52
+#define SYMDRIVE_STOP_MANUAL 53
+#define SYMDRIVE_DISCARD_MANUAL 54
+
+#define SYMDRIVE_START_FN 60
+#define SYMDRIVE_STOP_FN 61
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_enable_trackperf(int line, int flags)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC8, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (flags)
+                         );
+}
+
+// MJR added this, requires SymDriveSearcher...
+ALWAYS_INLINE void s2e_disable_trackperf(int line, int flags)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xC9, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (flags)
+                         );
+}
+
+// MJR added this, requires SymDriveSearcher...
+#define TRACKPERF_NONTRANSITIVE 0
+#define TRACKPERF_TRANSITIVE 1
+ALWAYS_INLINE void s2e_trackperf_fn(int line, const char *fn, int flags)
+{
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0xCA, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (line), "b" (fn), "c" (flags)
+                         );
+}
+
+/////////////////////////////////////// <-------------- MJR
+
 /** Fill buffer with unconstrained symbolic values without discarding concrete data. */
-static inline void s2e_make_concolic(void* buf, int size, const char* name)
+ALWAYS_INLINE void s2e_make_concolic(void* buf, int size, const char* name)
 {
     __s2e_touch_string(name);
     __s2e_touch_buffer(buf, size);
@@ -182,7 +497,7 @@ static inline void s2e_make_concolic(void* buf, int size, const char* name)
 }
 
 /** Returns true if ptr points to symbolic memory */
-static inline int s2e_is_symbolic(void* ptr, size_t size)
+ALWAYS_INLINE inline int s2e_is_symbolic(void* ptr, size_t size)
 {
     int result;
     __s2e_touch_buffer(ptr, 1);
@@ -196,7 +511,7 @@ static inline int s2e_is_symbolic(void* ptr, size_t size)
 }
 
 /** Concretize the expression. */
-static inline void s2e_concretize(void* buf, int size)
+ALWAYS_INLINE void s2e_concretize(void* buf, int size)
 {
     __s2e_touch_buffer(buf, size);
     __asm__ __volatile__(
@@ -211,7 +526,7 @@ static inline void s2e_concretize(void* buf, int size)
 }
 
 /** Get example value for expression (without adding state constraints). */
-static inline void s2e_get_example(void* buf, int size)
+ALWAYS_INLINE void s2e_get_example(void* buf, int size)
 {
     __s2e_touch_buffer(buf, size);
     __asm__ __volatile__(
@@ -227,7 +542,7 @@ static inline void s2e_get_example(void* buf, int size)
 
 /** Get example value for expression (without adding state constraints). */
 /** Convenience function to be used in printfs */
-static inline unsigned s2e_get_example_uint(unsigned val)
+ALWAYS_INLINE unsigned s2e_get_example_uint(unsigned val)
 {
     unsigned buf = val;
     __asm__ __volatile__(
@@ -243,8 +558,17 @@ static inline unsigned s2e_get_example_uint(unsigned val)
 }
 
 /** Terminate current state. */
-static inline void s2e_kill_state(int status, const char* message)
+// MJR changed implementation:
+// ALWAYS_INLINE void s2e_kill_state(int status, const char* message)
+ALWAYS_INLINE void s2e_kill_state(int kill_all, int status, const char* message)
 {
+    __asm__ __volatile__(
+        ".byte 0x0f, 0x3f\n"
+        ".byte 0x00, 0x06, 0x00, 0x00\n"
+        ".byte 0x00, 0x00, 0x00, 0x00\n"
+        : : "a" (kill_all), "d" (status), "c" (message)
+    );
+/*
     __s2e_touch_string(message);
     __asm__ __volatile__(
         "pushl %%ebx\n"
@@ -255,10 +579,11 @@ static inline void s2e_kill_state(int status, const char* message)
         "popl %%ebx\n"
         : : "a" (status), "d" (message)
     );
+*/
 }
 
 /** Disable timer interrupt in the guest. */
-static inline void s2e_disable_timer_interrupt()
+ALWAYS_INLINE void s2e_disable_timer_interrupt(void) // MJR
 {
     __asm__ __volatile__(
         ".byte 0x0f, 0x3f\n"
@@ -268,7 +593,7 @@ static inline void s2e_disable_timer_interrupt()
 }
 
 /** Enable timer interrupt in the guest. */
-static inline void s2e_enable_timer_interrupt()
+ALWAYS_INLINE void s2e_enable_timer_interrupt(void) // MJR
 {
     __asm__ __volatile__(
         ".byte 0x0f, 0x3f\n"
@@ -278,7 +603,7 @@ static inline void s2e_enable_timer_interrupt()
 }
 
 /** Disable all APIC interrupts in the guest. */
-static inline void s2e_disable_all_apic_interrupts()
+ALWAYS_INLINE void s2e_disable_all_apic_interrupts(void) // MJR
 {
     __asm__ __volatile__(
         ".byte 0x0f, 0x3f\n"
@@ -288,7 +613,7 @@ static inline void s2e_disable_all_apic_interrupts()
 }
 
 /** Enable all APIC interrupts in the guest. */
-static inline void s2e_enable_all_apic_interrupts()
+ALWAYS_INLINE void s2e_enable_all_apic_interrupts(void) // MJR
 {
     __asm__ __volatile__(
         ".byte 0x0f, 0x3f\n"
@@ -298,7 +623,7 @@ static inline void s2e_enable_all_apic_interrupts()
 }
 
 /** Get the current S2E_RAM_OBJECT_BITS configuration macro */
-static inline int s2e_get_ram_object_bits()
+ALWAYS_INLINE int s2e_get_ram_object_bits(void) // MJR
 {
     int bits;
     __asm__ __volatile__(
@@ -314,7 +639,7 @@ static inline int s2e_get_ram_object_bits()
  *  all states when they reach this point.
  *
  * NOTE: This requires merge searcher to be enabled. */
-static inline void s2e_merge_point()
+ALWAYS_INLINE void s2e_merge_point(void) // MJR
 {
     __asm__ __volatile__(
         ".byte 0x0f, 0x3f\n"
@@ -326,7 +651,7 @@ static inline void s2e_merge_point()
 /** Open file from the guest.
  *
  * NOTE: This require HostFiles plugin. */
-static inline int s2e_open(const char* fname)
+ALWAYS_INLINE int s2e_open(const char* fname)
 {
     int fd;
     __s2e_touch_string(fname);
@@ -342,7 +667,7 @@ static inline int s2e_open(const char* fname)
 /** Close file from the guest.
  *
  * NOTE: This require HostFiles plugin. */
-static inline int s2e_close(int fd)
+ALWAYS_INLINE int s2e_close(int fd)
 {
     int res;
     __asm__ __volatile__(
@@ -357,7 +682,7 @@ static inline int s2e_close(int fd)
 /** Read file content from the guest.
  *
  * NOTE: This require HostFiles plugin. */
-static inline int s2e_read(int fd, char* buf, int count)
+ALWAYS_INLINE int s2e_read(int fd, char* buf, int count)
 {
     int res;
     __s2e_touch_buffer(buf, count);
@@ -396,7 +721,7 @@ static inline void s2e_memtracer_disable()
 /** Raw monitor plugin */
 /** Communicates to S2E the coordinates of loaded modules. Useful when there is
     no plugin to automatically parse OS data structures */
-static inline void s2e_rawmon_loadmodule(const char *name, unsigned loadbase, unsigned size)
+ALWAYS_INLINE void s2e_rawmon_loadmodule(const char *name, unsigned loadbase, unsigned size)
 {
     __s2e_touch_string(name);
     __asm__ __volatile__(
@@ -410,6 +735,8 @@ static inline void s2e_rawmon_loadmodule(const char *name, unsigned loadbase, un
     );
 }
 
+#if 0
+//  MJR commented out
 typedef struct _s2e_opcode_module_config_t {
     uint32_t name;
     uint64_t nativeBase;
@@ -422,7 +749,7 @@ typedef struct _s2e_opcode_module_config_t {
 /** Raw monitor plugin */
 /** Communicates to S2E the coordinates of loaded modules. Useful when there is
     no plugin to automatically parse OS data structures */
-static inline void s2e_rawmon_loadmodule2(const char *name,
+ALWAYS_INLINE void s2e_rawmon_loadmodule2(const char *name,
                                          uint64_t nativebase,
                                          uint64_t loadbase,
                                          uint64_t entrypoint,
@@ -445,10 +772,13 @@ static inline void s2e_rawmon_loadmodule2(const char *name,
         : : "c" (&cfg)
     );
 }
+#endif
 
+#if 0
+// MJR commented out
 /** CodeSelector plugin */
 /** Enable forking in the current process (entire address space or user mode only) */
-static inline void s2e_codeselector_enable_address_space(unsigned user_mode_only)
+ALWAYS_INLINE void s2e_codeselector_enable_address_space(unsigned user_mode_only)
 {
     __asm__ __volatile__(
         ".byte 0x0f, 0x3f\n"
@@ -460,7 +790,7 @@ static inline void s2e_codeselector_enable_address_space(unsigned user_mode_only
 
 /** Disable forking in the specified process (represented by its page directory).
     If pagedir is 0, disable forking in the current process. */
-static inline void s2e_codeselector_disable_address_space(uint64_t pagedir)
+ALWAYS_INLINE void s2e_codeselector_disable_address_space(uint64_t pagedir)
 {
     __asm__ __volatile__(
         ".byte 0x0f, 0x3f\n"
@@ -469,8 +799,9 @@ static inline void s2e_codeselector_disable_address_space(uint64_t pagedir)
         : : "c" (pagedir)
     );
 }
+#endif
 
-static inline void s2e_codeselector_select_module(const char *moduleId)
+ALWAYS_INLINE void s2e_codeselector_select_module(const char *moduleId)
 {
     __s2e_touch_string(moduleId);
     __asm__ __volatile__(
@@ -482,7 +813,8 @@ static inline void s2e_codeselector_select_module(const char *moduleId)
 }
 
 /** Programmatically add a new configuration entry to the ModuleExecutionDetector plugin */
-static inline void s2e_moduleexec_add_module(const char *moduleId, const char *moduleName, int kernelMode)
+ALWAYS_INLINE void s2e_moduleexec_add_module(const char *moduleId, const char *moduleName, int kernelMode)
+   
 {
     __s2e_touch_string(moduleId);
     __s2e_touch_string(moduleName);
@@ -506,7 +838,9 @@ static inline void s2e_moduleexec_add_module(const char *moduleId, const char *m
  *
  * The returned name is an absolute path to the program file.
  */
-static inline int s2e_get_module_info(const char *moduleToRetrieve,
+#if 0
+//  MJR Commented out
+ALWAYS_INLINE int s2e_get_module_info(const char *moduleToRetrieve,
                                 char *name, size_t maxNameLength,
                                 uint64_t *loadBase, uint64_t *size)
 {
@@ -559,23 +893,25 @@ static inline int s2e_get_module_info(const char *moduleToRetrieve,
     fclose(maps);
     return result;
 }
+#endif
 
 /* Kills the current state if b is zero */
-static inline void _s2e_assert(int b, const char *expression )
+ALWAYS_INLINE void _s2e_assert(int b, const char *expression )
 {
    if (!b) {
-      s2e_kill_state(0, expression);
+       s2e_kill_state(1, 0, expression); // MJR added 1
    }
 }
 
 #define s2e_assert(expression) _s2e_assert(expression, "Assertion failed: "  #expression)
 
 /** Returns a symbolic value in [start, end) */
-static inline int s2e_range(int start, int end, const char* name) {
+ALWAYS_INLINE int s2e_range(int start, int end, const char* name)
+{
   int x = -1;
 
   if (start >= end) {
-    s2e_kill_state(1, "s2e_range: invalid range");
+      s2e_kill_state(1, 1, "s2e_range: invalid range"); // MJR added 1
   }
 
   if (start+1==end) {
@@ -586,11 +922,11 @@ static inline int s2e_range(int start, int end, const char* name) {
     /* Make nicer constraint when simple... */
     if (start==0) {
       if ((unsigned) x >= (unsigned) end) {
-        s2e_kill_state(0, "s2e_range creating a constraint...");
+          s2e_kill_state(1, 0, "s2e_range creating a constraint..."); // MJR added 1
       }
     } else {
       if (x < start || x >= end) {
-        s2e_kill_state(0, "s2e_range creating a constraint...");
+          s2e_kill_state(1, 0, "s2e_range creating a constraint..."); // MJR added 1
       }
     }
 
@@ -598,21 +934,4 @@ static inline int s2e_range(int start, int end, const char* name) {
   }
 }
 
-/**
- *  Transmits a buffer of dataSize length to the plugin named in pluginName.
- *  eax contains the failure code upon return, 0 for success.
- */
-static inline int s2e_invoke_plugin(const char *pluginName, void *data, uint32_t dataSize)
-{
-    int result;
-    __s2e_touch_string(pluginName);
-    __s2e_touch_buffer(data, dataSize);
-    __asm__ __volatile__(
-        ".byte 0x0f, 0x3f\n"
-        ".byte 0x00, 0x0b, 0x00, 0x00\n"
-        ".byte 0x00, 0x00, 0x00, 0x00\n"
-        : "=a" (result) : "a" (pluginName), "c" (data), "d" (dataSize) : "memory"
-    );
-
-    return result;
-}
+#endif
diff --git a/klee/lib/Core/AddressSpace.cpp b/klee/lib/Core/AddressSpace.cpp
index 3b7b805..ea6527c 100644
--- a/klee/lib/Core/AddressSpace.cpp
+++ b/klee/lib/Core/AddressSpace.cpp
@@ -15,6 +15,7 @@
 #include "klee/Expr.h"
 #include "klee/TimerStatIncrementer.h"
 #include "klee/ExecutionState.h"
+#include "klee/Executor.h"
 
 using namespace klee;
 
@@ -351,6 +352,41 @@ bool AddressSpace::copyInConcretes() {
   return true;
 }
 
+//
+// The purpose of this function is to concretize all symbolic
+// data in the current "address space."  The idea is to collapse all
+// the constraints, and just give us concrete data.  Ideally we'd not
+// need this but sometimes constraints get out of hand.
+//
+void AddressSpace::concretizeAll(Executor *e) {
+    unsigned int object_offset;
+    int i, j;
+    i = 0;
+    j = 0;
+    for (MemoryMap::iterator it = objects.begin(),
+             ie = objects.end(); it != ie; ++it) {
+        ObjectState *os = it->second;
+        for (object_offset = 0; object_offset < os->size; object_offset++) {
+            ref<klee::Expr> oldexpr;
+            if (os->knownSymbolics != NULL) {
+                oldexpr = os->knownSymbolics[object_offset];
+            } else {
+                continue;
+            }
+
+            if (oldexpr.get() == NULL) {
+                continue;
+            }
+
+            ref<klee::ConstantExpr> expr = e->toConstantSilent(*state, oldexpr);
+            os->setKnownSymbolic (object_offset, expr.get());
+            j++;
+        }
+        i++;
+    }
+    // std::cerr << "AddressSpace: " << i << ", " << j << std::endl;
+}
+
 /***/
 
 bool MemoryObjectLT::operator()(const MemoryObject *a, const MemoryObject *b) const {
diff --git a/klee/lib/Core/AddressSpace.h b/klee/lib/Core/AddressSpace.h
index 276a865..d9440df 100644
--- a/klee/lib/Core/AddressSpace.h
+++ b/klee/lib/Core/AddressSpace.h
@@ -16,6 +16,7 @@
 #include "klee/Internal/ADT/ImmutableMap.h"
 
 namespace klee {
+  class Executor;
   class ExecutionState;
   class MemoryObject;
   class ObjectState;
@@ -134,6 +135,8 @@ namespace klee {
     /// \retval true The copy succeeded. 
     /// \retval false The copy failed because a read-only object was modified.
     bool copyInConcretes();
+
+    void concretizeAll(Executor *e); // MJR
   };
 } // End klee namespace
 
diff --git a/qemu/Makefile.target b/qemu/Makefile.target
index 1e6960a..28d8664 100644
--- a/qemu/Makefile.target
+++ b/qemu/Makefile.target
@@ -496,6 +496,8 @@ s2eobj-y += s2e/Plugins/Annotation.o
 s2eobj-y += s2e/Plugins/Searchers/MaxTbSearcher.o
 s2eobj-y += s2e/Plugins/Searchers/CooperativeSearcher.o
 s2eobj-y += s2e/Plugins/Searchers/ConcolicDFSSearcher.o
+s2eobj-y += s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.o
+s2eobj-y += s2e/Plugins/SymDrive/SymDriveSearcher.o
 s2eobj-y += s2e/Plugins/HostFiles.o
 
 s2eobj-y += s2e/Plugins/MemoryChecker.o
@@ -540,6 +542,8 @@ s2e/Plugins/ExecutionTracers/InstructionCounter.o: QEMU_CXXFLAGS+=-fno-inline
 s2e/Plugins/ExecutionTracers/TranslationBlockTracer.o: QEMU_CXXFLAGS+=-fno-inline
 s2e/Plugins/Searchers/MaxTbSearcher.o: QEMU_CXXFLAGS+=-fno-inline
 s2e/Plugins/Searchers/CooperativeSearcher.o: QEMU_CXXFLAGS+=-fno-inline
+s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.o: QEMU_CXXFLAGS+=-fno-inline
+s2e/Plugins/SymDrive/SymDriveSearcher.o: QEMU_CXXFLAGS+=-fno-inline
 s2e/Plugins/WindowsApi/NdisHandlers.o: QEMU_CXXFLAGS+=-fno-inline
 s2e/Plugins/WindowsApi/NdisProtocolHandlers.o: QEMU_CXXFLAGS+=-fno-inline
 s2e/Plugins/WindowsApi/NtoskrnlHandlers.o: QEMU_CXXFLAGS+=-fno-inline
diff --git a/qemu/configure b/qemu/configure
index 848949c..3ab5d7d 100755
--- a/qemu/configure
+++ b/qemu/configure
@@ -3831,7 +3831,7 @@ symlink $source_path/Makefile.target $target_dir/Makefile
 if test "$target_s2e" = "yes"; then
   S2E_DIRS="s2e s2e/Interceptor s2e/Plugins s2e/Plugins/WindowsInterceptor s2e/Configuration s2e/Signals"
   S2E_DIRS="$S2E_DIRS s2e/Plugins/DataSelectors s2e/Plugins/ExecutionTracers"
-  S2E_DIRS="$S2E_DIRS s2e/Plugins/WindowsApi s2e/Plugins/Searchers"
+  S2E_DIRS="$S2E_DIRS s2e/Plugins/WindowsApi s2e/Plugins/Searchers s2e/Plugins/SymDrive"
   for dir in $S2E_DIRS ; do
     mkdir -p $target_dir/$dir
   done
diff --git a/qemu/exec.c b/qemu/exec.c
index 847d89f..9c6cdbb 100644
--- a/qemu/exec.c
+++ b/qemu/exec.c
@@ -4879,6 +4879,39 @@ tb_page_addr_t get_page_addr_code(CPUArchState *env1, target_ulong addr)
     return qemu_ram_addr_from_host_nofail(p);
 }
 
+#ifdef CONFIG_S2E
+uint64_t symbhw_read(void *opaque, target_phys_addr_t addr, unsigned size);
+void symbhw_write(void *opaque, target_phys_addr_t addr, uint64_t data, unsigned size);
+
+int s2e_issymfunc(struct MemoryRegion *mr, target_ulong addr)
+{
+    subpage_t *mmio;
+    unsigned int idx;
+    MemoryRegionSection *section;
+    void *fr, *fw;
+
+    fr = mr->ops->read;
+    fw = mr->ops->write;
+
+    if (fr == subpage_read &&
+        fw == subpage_write) {
+        int result;
+        mmio = (subpage_t *) mr->opaque;
+        idx = SUBPAGE_IDX(addr);
+        section = &phys_sections[mmio->sub_section[idx]];
+
+        result =
+            (section->mr->ops->read == symbhw_read) &&
+            (section->mr->ops->write == symbhw_write);
+        return result;
+    } else if (fr == symbhw_read &&
+               fw == symbhw_write) {
+        return 1;
+    }
+    return 0;
+}
+#endif
+
 /*
  * A helper function for the _utterly broken_ virtio device model to find out if
  * it's running on a big endian machine. Don't do this at home kids!
diff --git a/qemu/hw/fakepci.c b/qemu/hw/fakepci.c
index 0c5f954..a078529 100644
--- a/qemu/hw/fakepci.c
+++ b/qemu/hw/fakepci.c
@@ -44,6 +44,10 @@
 #include "qemu-common.h"
 #include "hw/hw.h"
 #include "hw/pci.h"
+
+#include "hw/msi.h" // MSI support
+#include "hw/pcie.h" // PCI-E support
+
 #include "fakepci.h"
 
 
@@ -76,7 +80,7 @@ typedef struct _PCIFakeState {
     PCIDevice dev;
     fake_pci_t fake_pci;
     MemoryRegion io[PCI_NUM_REGIONS];
-}PCIFakeState;
+} PCIFakeState;
 
 static int pci_fake_init(PCIDevice *pci_dev)
 {
@@ -88,13 +92,48 @@ static int pci_fake_init(PCIDevice *pci_dev)
 
     pci_conf = d->dev.config;
     pci_conf[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
-    pci_conf[0x3d] = 1; // interrupt pin 0
+    pci_conf[PCI_INTERRUPT_PIN] = 1; // interrupt pin 0
 
     char *name_io = malloc(strlen(d->fake_pci.name) + 20);
     char *name_mmio = malloc(strlen(d->fake_pci.name) + 20);
     sprintf(name_io, "%s-io", d->fake_pci.name);
     sprintf(name_mmio, "%s-mmio", d->fake_pci.name);
 
+    if (d->fake_pci.cap_pm > 0) {
+        // Force PCI power management to ON
+        int r = pci_add_capability(pci_dev, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF);
+        assert (r >= 0 && "Why isn't power management working?");
+    }
+
+    if (d->fake_pci.cap_msi > 0) {
+        // The 0 = find a valid PCI capability offset.
+        // 0x50 seems to work FWIW
+        // The first 64 bytes of PCI config space are
+        // standardized, so 0x50 = the first byte after that.
+        // If we add more capabilities this number might need
+        // to be changed.
+        // false = msi64bit (4th param)
+        // false = msi_per_vector_mask (5th param)
+        msi_init(pci_dev, 0, d->fake_pci.cap_msi, false, false);
+    } else {
+        assert (d->fake_pci.cap_msi == 0 && "?? MSI should be >= 0");
+    }
+
+    if (d->fake_pci.cap_pcie > 0) {
+        int r = pcie_cap_init(pci_dev, 0, PCI_EXP_TYPE_ENDPOINT, 0);
+        assert (r >= 0 && "Why isn't PCI-E working?");
+    }
+
+    if (d->fake_pci.cap_pm > 0) {
+        assert (pci_find_capability(pci_dev, PCI_CAP_ID_PM) != 0 && "cap PM bug.");
+    }
+    if (d->fake_pci.cap_msi > 0) {
+        assert (pci_find_capability(pci_dev, PCI_CAP_ID_MSI) != 0 && "cap MSI bug.");
+    }
+    if (d->fake_pci.cap_pcie > 0) {
+        assert (pci_find_capability(pci_dev, PCI_CAP_ID_EXP) != 0 && "cap PCI-E bug.");
+    }
+
     for(i=0; i<d->fake_pci.num_resources; ++i) {
         int type = d->fake_pci.resources[i].type;
         int size = d->fake_pci.resources[i].size;
@@ -102,7 +141,7 @@ static int pci_fake_init(PCIDevice *pci_dev)
 
         if (type == PCI_BASE_ADDRESS_SPACE_IO) {
             name = name_io;
-        } else if (type == PCI_BASE_ADDRESS_SPACE_MEMORY) {
+        } else /* if (type == PCI_BASE_ADDRESS_SPACE_MEMORY) MJR */ {
             name = name_mmio;
         }
 
@@ -124,11 +163,22 @@ static int pci_fake_uninit(PCIDevice *dev)
         memory_region_destroy(&d->io[i]);
     }
 
+    // PM support requires no special shutdown
+
+    // MSI support
+    if (d->fake_pci.cap_msi > 0) {
+        msi_uninit(dev);
+    }
+
+    // PCI-E support
+    if (d->fake_pci.cap_pcie > 0) {
+        pcie_cap_exit(dev);
+    }
+
     return 0;
 }
 
-
-static  VMStateDescription vmstate_pci_fake = {
+static VMStateDescription vmstate_pci_fake = {
     .name = "fakepci",
     .version_id = 3,
     .minimum_version_id = 3,
@@ -139,6 +189,16 @@ static  VMStateDescription vmstate_pci_fake = {
     }
 };
 
+static VMStateDescription vmstate_pcie_fake = {
+    .name = "fakepci",
+    .version_id = 3,
+    .minimum_version_id = 3,
+    .minimum_version_id_old = 3,
+    .fields      = (VMStateField []) {
+        VMSTATE_PCIE_DEVICE(dev, PCIFakeState),
+        VMSTATE_END_OF_LIST()
+    }
+};
 
 static Property fakepci_properties[] = {
     DEFINE_PROP_END_OF_LIST(),
@@ -149,6 +209,11 @@ static void fakepci_class_init(ObjectClass *klass, void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
+    // PCI-E support
+    if (s_fake_pci->cap_pcie > 0) {
+        k->is_express = 1;
+    }
+
     k->init = pci_fake_init;
     k->exit = pci_fake_uninit;
 
@@ -159,7 +224,12 @@ static void fakepci_class_init(ObjectClass *klass, void *data)
     k->subsystem_vendor_id = s_fake_pci->ss_vendor_id;
     k->subsystem_id = s_fake_pci->ss_id;
 
-    dc->vmsd = &vmstate_pci_fake;
+    if (s_fake_pci->cap_pcie > 0) {
+        dc->vmsd = &vmstate_pcie_fake;
+    } else {
+        dc->vmsd = &vmstate_pci_fake;
+    }
+
     dc->props = fakepci_properties;
 }
 
@@ -200,7 +270,11 @@ void fakepci_register_device(fake_pci_t *fake)
 
 
     fakepci_info.name = s_fake_pci->name;
+
+    // Just assign both -- we'll only actually use one of these though
+    vmstate_pcie_fake.name = s_fake_pci->name;
     vmstate_pci_fake.name = s_fake_pci->name;
+    
     type_register_static(&fakepci_info);
 }
 
diff --git a/qemu/hw/fakepci.h b/qemu/hw/fakepci.h
index 7dda80d..56e34ff 100644
--- a/qemu/hw/fakepci.h
+++ b/qemu/hw/fakepci.h
@@ -16,6 +16,10 @@ typedef struct _fake_pci_t {
     int num_resources;
     PCIIORegion resources[PCI_NUM_REGIONS];
     int mmioidx;
+
+    int cap_pm;
+    int cap_msi;
+    int cap_pcie;
 }fake_pci_t;
 
 enum fake_bus_type_t {
diff --git a/qemu/hw/pci.c b/qemu/hw/pci.c
index e149305..d6f06ef 100644
--- a/qemu/hw/pci.c
+++ b/qemu/hw/pci.c
@@ -1566,6 +1566,7 @@ PCIDevice *pci_create_simple(PCIBus *bus, int devfn, const char *name)
     return pci_create_simple_multifunction(bus, devfn, false, name);
 }
 
+/*
 static int pci_find_space(PCIDevice *pdev, uint8_t size)
 {
     int config_size = pci_config_size(pdev);
@@ -1578,6 +1579,23 @@ static int pci_find_space(PCIDevice *pdev, uint8_t size)
             return offset;
     return 0;
 }
+*/
+static int pci_find_space(PCIDevice *pdev, uint8_t size)
+{
+    int config_size = pci_config_size(pdev);
+    int offset = PCI_CONFIG_HEADER_SIZE;
+    int i;
+    int masked;
+    for (i = PCI_CONFIG_HEADER_SIZE; i < config_size; ++i) {
+        masked = i & (~3);
+        if (pdev->used[i]) {
+            offset = masked + 4;
+        } else if (i - offset + 1 == size) {
+            return offset;
+        }
+    }
+    return 0;
+}
 
 static uint8_t pci_find_capability_list(PCIDevice *pdev, uint8_t cap_id,
                                         uint8_t *prev_p)
diff --git a/qemu/llvm-lib.h b/qemu/llvm-lib.h
index 76a47b1..43e7dfb 100644
--- a/qemu/llvm-lib.h
+++ b/qemu/llvm-lib.h
@@ -48,7 +48,8 @@ uint8_t klee_int8(const char *name);
 uint16_t klee_int16(const char *name);
 uint32_t klee_int32(const char *name);
 void uint32_to_string(uint32_t n, char *str);
-void trace_port(char *buf, const char *prefix, uint32_t port, uint32_t pc);
+
+void trace_port(char *buf, const char *prefix, uint32_t port, uint32_t pc, uint32_t unique_id /* MJR */);
 
 uint8_t klee_int8(const char *name) {
     uint8_t ret;
@@ -83,7 +84,7 @@ void uint32_to_string(uint32_t n, char *str)
   str[7] = hextable[((n >> 0) & 0xF)];
 }
 
-void trace_port(char *buf, const char *prefix, uint32_t port, uint32_t pc)
+void trace_port(char *buf, const char *prefix, uint32_t port, uint32_t pc, uint32 unique_id /* MJR */)
 {
     while(*prefix) {
         *buf = *prefix;
@@ -94,8 +95,14 @@ void trace_port(char *buf, const char *prefix, uint32_t port, uint32_t pc)
     buf+=8;
     *buf = '_';
     buf++;
+
     uint32_to_string(pc, buf);
     buf+=8;
+    *buf = '_';
+    buf++;
+
+    uint32_to_string(unique_id, buf);
+    buf+=8;
     *buf = 0;
 }
 
diff --git a/qemu/qemu-options.hx b/qemu/qemu-options.hx
index 6454b85..ec77009 100644
--- a/qemu/qemu-options.hx
+++ b/qemu/qemu-options.hx
@@ -68,6 +68,15 @@ DEF("fake-pci-resource-mem-prefetch", HAS_ARG, QEMU_OPTION_fake_pci_resource_mem
 DEF("fake-pci-resource-rom", HAS_ARG, QEMU_OPTION_fake_pci_resource_rom,
     "fake-pci-resource-rom\n", QEMU_ARCH_ALL)
 
+DEF("fake-pci-cap-pm", HAS_ARG, QEMU_OPTION_fake_pci_cap_pm,
+    "fake-pci-cap-pm\n", QEMU_ARCH_ALL)
+
+DEF("fake-pci-cap-msi", HAS_ARG, QEMU_OPTION_fake_pci_cap_msi,
+    "fake-pci-cap-msi\n", QEMU_ARCH_ALL)
+
+DEF("fake-pci-cap-pcie", HAS_ARG, QEMU_OPTION_fake_pci_cap_pcie,
+    "fake-pci-cap-pcie\n", QEMU_ARCH_ALL)
+
 #endif
 
 
diff --git a/qemu/s2e/MMUFunctionHandlers.cpp b/qemu/s2e/MMUFunctionHandlers.cpp
index 99e3f19..37822e3 100644
--- a/qemu/s2e/MMUFunctionHandlers.cpp
+++ b/qemu/s2e/MMUFunctionHandlers.cpp
@@ -66,16 +66,37 @@ namespace s2e {
 //XXX: Fix this
 #define CPU_MMU_INDEX 0
 
+#define MJR_TRACE(ADDRESS, VALUE, WIDTH, ISWRITE, ISDMA)                \
+    do {                                                                \
+        std::vector<ref<Expr> > traceArgs;                              \
+        traceArgs.push_back(ADDRESS);                                   \
+        traceArgs.push_back(VALUE);                                     \
+        traceArgs.push_back(ConstantExpr::create(WIDTH, Expr::Int64));  \
+        traceArgs.push_back(ConstantExpr::create(ISWRITE, Expr::Int64)); \
+        if (!(ISDMA)) {                                                 \
+            S2EExecutor::handlerTraceMemoryAccess(g_s2e->getExecutor(), state, target, traceArgs); \
+        } else {                                                        \
+            S2EExecutor::handlerTraceDMAAccess(g_s2e->getExecutor(), state, target, traceArgs); \
+        }                                                               \
+    } while (0)
+    
 //This is an io_write_chkX_mmu function
 static void io_write_chk(S2EExecutionState *state,
                              target_phys_addr_t physaddr,
                              ref<Expr> val,
                              target_ulong addr,
-                             void *retaddr, Expr::Width width)
+                             void *retaddr,
+                             Expr::Width width, // MJR width in bits
+                             klee::KInstruction* target, // MJR
+                             ref<Expr> symbAddress) // MJR
 {
     target_phys_addr_t origaddr = physaddr;
     MemoryRegion *mr = iotlb_to_region(physaddr);
 
+    // MJR naddr is phys addr in VM, added these two lines:
+    target_ulong naddr = (physaddr & TARGET_PAGE_MASK)+addr;
+    int isDMASymb = g_s2e->getCorePlugin()->isMmioSymbolic(naddr, width / 8);
+
     physaddr = (physaddr & TARGET_PAGE_MASK) + addr;
     if (mr != &io_mem_ram && mr != &io_mem_rom
         && mr != &io_mem_unassigned
@@ -84,17 +105,27 @@ static void io_write_chk(S2EExecutionState *state,
         cpu_io_recompile(env, retaddr);
     }
 
-
     env->mem_io_vaddr = addr;
     env->mem_io_pc = (uintptr_t)retaddr;
 #ifdef TARGET_WORDS_BIGENDIAN
     #error This is not implemented yet.
 #else
     if (s2e_ismemfunc(mr, 1)) {
+        // MJR isWrite = 1
+        // MJR isDMA = 1
+        if (isDMASymb) { // MJR added this block
+            MJR_TRACE(symbAddress, val, width, 1, 1); // MJR
+        }
         uintptr_t pa = s2e_notdirty_mem_write(physaddr);
         state->writeMemory(pa, val, S2EExecutionState::HostAddress);
         return;
     }
+    if (s2e_issymfunc(mr, addr)) { // MJR added this block
+        // MJR isWrite = 1
+        // MJR isDMA = 0
+        MJR_TRACE(symbAddress, val, width, 1, 0); // MJR
+        return; // All done -- no need to "write" to symbolic memory ?? MJR maybe?
+    }
 #endif
 
     //XXX: Check if MMIO is symbolic, and add corresponding trace entry
@@ -119,19 +150,25 @@ static void io_write_chk(S2EExecutionState *state,
 static ref<Expr> io_read_chk(S2EExecutionState *state,
                              target_phys_addr_t physaddr,
                              target_ulong addr,
-                             void *retaddr, Expr::Width width)
+                             void *retaddr, Expr::Width width, // MJR width in bits
+                             klee::KInstruction* target, // MJR
+                             ref<Expr> symbAddress) // MJR
 {
     ref<Expr> res;
     target_phys_addr_t origaddr = physaddr;
     MemoryRegion *mr = iotlb_to_region(physaddr);
 
     target_ulong naddr = (physaddr & TARGET_PAGE_MASK)+addr;
-    int isSymb = g_s2e->getCorePlugin()->isMmioSymbolic(naddr, width / 8);;
+    int isDMASymb = g_s2e->getCorePlugin()->isMmioSymbolic(naddr, width / 8); // MJR naddr is phys addr in VM
+    int isSymb = s2e_issymfunc(mr, addr); // MJR
     std::stringstream ss;
     if (isSymb) {
         //If at least one byte is symbolic, generate a label
         ss << "iommuread_" << hexval(naddr) << "@" << hexval(env->eip);
     }
+    if (isDMASymb) { // MJR added this
+        ss << "dmaread_" << hexval(naddr) << "@" << hexval(env->eip);
+    }
 
     //If it is not DMA, then check if it is normal memory
     env->mem_io_pc = (uintptr_t)retaddr;
@@ -143,12 +180,27 @@ static ref<Expr> io_read_chk(S2EExecutionState *state,
     }
 
     env->mem_io_vaddr = addr;
-    if (s2e_ismemfunc(mr, 0)) {
-        uintptr_t pa = s2e_notdirty_mem_write(physaddr);
-        if (isSymb) {
-            return state->createSymbolicValue(ss.str(), width);
+    //if (s2e_ismemfunc(mr, 0)) { // MJR
+        if (isDMASymb) { // MJR modified this block
+            // MJR isWrite = 0
+            // MJR isDMA = 1
+            ref<Expr> symbolicResult = state->createSymbolicValue(ss.str(), width);
+            MJR_TRACE(symbAddress, symbolicResult, width, 0, 1); // MJR
+            g_s2e->getCorePlugin()->establishIOMap (ss.str()); // MJR
+            return symbolicResult;
         }
-        return state->readMemory(pa, width, S2EExecutionState::HostAddress);
+// MJR
+//        uintptr_t pa = s2e_notdirty_mem_write(physaddr); // MJR moved this
+//        return state->readMemory(pa, width, S2EExecutionState::HostAddress);
+//    }
+
+    if (isSymb) { // MJR added this block
+        // MJR isWrite = 0
+        // MJR isDMA = 0
+        ref<Expr> symbolicResult = state->createSymbolicValue(ss.str(), width);
+        MJR_TRACE(symbAddress, symbolicResult, width, 0, 0); // MJR
+        g_s2e->getCorePlugin()->establishIOMap (ss.str()); // MJR
+        return symbolicResult;
     }
 
     //By default, call the original io_read function, which is external
@@ -284,9 +336,12 @@ ref<Expr> S2EExecutor::handle_ldst_mmu(Executor* executor,
             ioaddr = env->iotlb[mmu_idx][index];
 
             if (!isWrite)
-                value = io_read_chk(s2estate, ioaddr, addr, retaddr, width);
+                // MJR Added symbAddress
+                value = io_read_chk(s2estate, ioaddr, addr, retaddr, width, target, symbAddress);
 
             //Trace the access
+            /*
+              MJR
             std::vector<ref<Expr> > traceArgs;
             traceArgs.push_back(symbAddress);
             traceArgs.push_back(ConstantExpr::create(addr + ioaddr, Expr::Int64));
@@ -295,9 +350,11 @@ ref<Expr> S2EExecutor::handle_ldst_mmu(Executor* executor,
             traceArgs.push_back(ConstantExpr::create(isWrite, Expr::Int64)); //isWrite
             traceArgs.push_back(ConstantExpr::create(1, Expr::Int64)); //isIO
             handlerTraceMemoryAccess(executor, state, target, traceArgs);
+            */
 
            if (isWrite)
-               io_write_chk(s2estate, ioaddr, value, addr, retaddr, width);
+               // MJR Added symbAddress
+               io_write_chk(s2estate, ioaddr, value, addr, retaddr, width, target, symbAddress);
 
         } else if (unlikely(((addr & ~S2E_RAM_OBJECT_MASK) + data_size - 1) >= S2E_RAM_OBJECT_SIZE)) {
             /* slow unaligned access (it spans two pages or IO) */
@@ -356,6 +413,8 @@ ref<Expr> S2EExecutor::handle_ldst_mmu(Executor* executor,
             }
 
             //Trace the access
+            /*
+              MJR
             std::vector<ref<Expr> > traceArgs;
             traceArgs.push_back(symbAddress);
             traceArgs.push_back(ConstantExpr::create(addr + addend, Expr::Int64));
@@ -364,6 +423,7 @@ ref<Expr> S2EExecutor::handle_ldst_mmu(Executor* executor,
             traceArgs.push_back(ConstantExpr::create(isWrite, Expr::Int64)); //isWrite
             traceArgs.push_back(ConstantExpr::create(0, Expr::Int64)); //isIO
             handlerTraceMemoryAccess(executor, state, target, traceArgs);
+            */
        }
     } else {
         /* the page is not in the TLB : fill it */
@@ -491,6 +551,8 @@ void S2EExecutor::handle_ldst_kernel(Executor* executor,
         }
 
         //Trace the access
+        /*
+          MJR
         std::vector<ref<Expr> > traceArgs;
         traceArgs.push_back(constantAddress);
         traceArgs.push_back(ConstantExpr::create(physaddr, Expr::Int64));
@@ -499,6 +561,7 @@ void S2EExecutor::handle_ldst_kernel(Executor* executor,
         traceArgs.push_back(ConstantExpr::create(isWrite, Expr::Int64)); //isWrite
         traceArgs.push_back(ConstantExpr::create(0, Expr::Int64)); //isIO
         handlerTraceMemoryAccess(executor, state, target, traceArgs);
+        */
 
         if (!isWrite) {
             if (zeroExtend) {
diff --git a/qemu/s2e/Plugins/BaseInstructions.cpp b/qemu/s2e/Plugins/BaseInstructions.cpp
index 97308d5..2461634 100644
--- a/qemu/s2e/Plugins/BaseInstructions.cpp
+++ b/qemu/s2e/Plugins/BaseInstructions.cpp
@@ -169,6 +169,51 @@ void BaseInstructions::isSymbolic(S2EExecutionState *state)
 
 void BaseInstructions::killState(S2EExecutionState *state)
 {
+    // SymDrive implementation
+    std::string message;
+    uint32_t messagePtr;
+    bool ok = true;
+    klee::ref<klee::Expr> kill_all = state->readCpuRegister(CPU_OFFSET(regs[R_EAX]), klee::Expr::Int32);
+    klee::ref<klee::Expr> status = state->readCpuRegister(CPU_OFFSET(regs[R_EBX]), klee::Expr::Int32);
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_ECX]), &messagePtr, 4);
+
+    if (!ok) {
+        s2e()->getWarningsStream(state)
+            << "ERROR: symbolic argument was passed to s2e_op kill state\n";
+    } else {
+        message="<NO MESSAGE>";
+        if(!messagePtr || !state->readString(messagePtr, message)) {
+            s2e()->getWarningsStream(state)
+                << "s2e_kill_state:  error reading message string from the guest\n";
+        }
+    }
+
+    bool isKillAllCste = isa<klee::ConstantExpr>(kill_all);
+    int i_kill_all = isKillAllCste ? cast<klee::ConstantExpr>(kill_all)->getZExtValue(64) : 0;
+    if (i_kill_all == 0) {
+        if (s2e()->getExecutor()->getStatesCount() == 1) {
+            s2e()->getWarningsStream(state) << "Not killing state " << state->getID()
+                                            << " since it's the only one!\n";
+            s2e()->getWarningsStream(state) << "Message from guest: \"" << message << "\"\n"
+                                            << "status: " << status << "\n";
+            return;
+        }
+    }
+
+    //Kill the current state                                                                                
+    s2e()->getWarningsStream(state) << "Killing state "  << state->getID() << "\n";
+    std::ostringstream os;
+    os << "State was terminated by opcode\n"
+       << "            message: \"" << message << "\"\n"
+       << "            status: " << status << "\n";
+    s2e()->getWarningsStream(state) << "Message: " << os;
+    s2e()->getExecutor()->terminateStateEarly(*state, os.str());
+    return;
+}
+
+// SymDrive: original implementation
+/*
+{
     std::string message;
     uint32_t messagePtr;
     bool ok = true;
@@ -194,6 +239,7 @@ void BaseInstructions::killState(S2EExecutionState *state)
        << "            status: " << status;
     s2e()->getExecutor()->terminateStateEarly(*state, os.str());
 }
+*/
 
 void BaseInstructions::printExpression(S2EExecutionState *state)
 {
@@ -317,18 +363,20 @@ void BaseInstructions::printMessage(S2EExecutionState *state, bool isWarning)
     }
 
     std::string str="";
-    if(!address || !state->readString(address, str)) {
+    if(!address || !state->readString(address, str, 4096)) { // SymDrive: added 4096 as maxlen, default is 256
         s2e()->getWarningsStream(state)
                 << "Error reading string message from the guest at address "
-                << hexval(address) << '\n';
-    } else {
+                << hexval(address) << ", printing partial message:" << '\n'; // SymDrive
+    } /* SymDrive else */ {
         llvm::raw_ostream *stream;
         if(isWarning)
             stream = &s2e()->getWarningsStream(state);
         else
             stream = &s2e()->getMessagesStream(state);
-        (*stream) << "Message from guest (" << hexval(address) <<
-                     "): " <<  str << '\n';
+
+        (*stream) << "Guest: " <<  str; // SymDrive
+        //(*stream) << "Message from guest (" << hexval(address) <<
+        //    "): " <<  str /* SymDrive << '\n' */;
     }
 }
 
diff --git a/qemu/s2e/Plugins/CorePlugin.cpp b/qemu/s2e/Plugins/CorePlugin.cpp
index c0d9ad9..89cad5d 100644
--- a/qemu/s2e/Plugins/CorePlugin.cpp
+++ b/qemu/s2e/Plugins/CorePlugin.cpp
@@ -328,6 +328,7 @@ void s2e_init_timers(S2E* s2e)
     s2e->getCorePlugin()->initializeTimers();
 }
 
+#if 0 // SymDrive
 static void s2e_trace_memory_access_slow(
         uint64_t vaddr, uint64_t haddr, uint8_t* buf, unsigned size,
         int isWrite, int isIO)
@@ -358,6 +359,56 @@ void s2e_trace_memory_access(
         s2e_trace_memory_access_slow(vaddr, haddr, buf, size, isWrite, isIO);
     }
 }
+#endif
+
+void s2e_trace_memory_access(
+    struct S2E *s2e, struct S2EExecutionState* state,
+    uint64_t vaddr, uint8_t* buf, unsigned size, int isWrite)
+{
+/* // SymDrive
+   if(!s2e->getCorePlugin()->onDataMemoryAccess.empty()) {
+   uint64_t value = 0;
+   memcpy((void*) &value, buf, size);
+
+   try {
+   s2e->getCorePlugin()->onDataMemoryAccess.emit(state,
+   klee::ConstantExpr::create(vaddr, 64),
+   klee::ConstantExpr::create(haddr, 64),
+   klee::ConstantExpr::create(value, size*8),
+   isWrite, isIO != 0 ? true : false); // SymDrive tweaked
+   } catch(s2e::CpuExitException&) {
+   longjmp(env->jmp_env, 1);
+   }
+   }
+*/
+
+    // SymDrive, added this:
+    if(/* isIO == 2 && */!g_s2e->getCorePlugin()->onIOMemoryAccess.empty()) {
+
+        try {
+            // Parameters to onIOMemoryAccess.
+            // Address:
+            klee::ref<klee::Expr> eAddress = klee::ConstantExpr::create(vaddr, 64);
+
+            // Data / size:
+            uint64_t value = 0;
+            memcpy((void*) &value, buf, size);
+            klee::ref<klee::Expr> eValue = klee::ConstantExpr::create(value, size*8);
+            int accessType = 1; // MMIO
+            g_s2e->getCorePlugin()->onIOMemoryAccess.emit(
+                state,
+                accessType,
+                eAddress,
+                eValue,
+                size,
+                isWrite);
+            g_s2e->getMessagesStream() << "s2e_trace_memory_access: Finished I/O memory access\n";
+        } catch(s2e::CpuExitException&) {
+            g_s2e->getMessagesStream() << "s2e_trace_memory_access: Caught CPUExitException\n";
+            s2e_longjmp(env->jmp_env, 1);
+        }
+    }
+}
 
 void s2e_on_page_fault(S2E *s2e, S2EExecutionState* state, uint64_t addr, int is_write)
 {
@@ -393,6 +444,7 @@ void s2e_trace_port_access(
         uint64_t port, uint64_t value, unsigned size,
         int isWrite)
 {
+/* SymDrive commented
     if(!s2e->getCorePlugin()->onPortAccess.empty()) {
         try {
             s2e->getCorePlugin()->onPortAccess.emit(state,
@@ -403,6 +455,29 @@ void s2e_trace_port_access(
             s2e_longjmp(env->jmp_env, 1);
         }
     }
+*/
+    // SymDrive added this:
+    if(!s2e->getCorePlugin()->onIOMemoryAccess.empty()) {
+        try {
+            // We're ignoring host addr
+            // Parameters to onIOMemoryAccess:
+            int accessType = 0; // Port I/O
+            klee::ref<klee::Expr> eAddress = klee::ConstantExpr::create(port, 64);
+            klee::ref<klee::Expr> eValue = klee::ConstantExpr::create(value, 64);
+
+            s2e->getCorePlugin()->onIOMemoryAccess.emit(
+                state,
+                accessType,
+                eAddress, // vaddr
+                eValue,   // value
+                size,     // size in bytes
+                isWrite); // isWrite
+            s2e->getMessagesStream() << "s2e_trace_port_access: Finished port access\n";
+        } catch(s2e::CpuExitException&) {
+            s2e->getMessagesStream() << "s2e_trace_port_access: Caught CPUExitException\n";
+            s2e_longjmp(env->jmp_env, 1);
+        }
+    }
 }
 
 int s2e_is_port_symbolic(struct S2E *s2e, struct S2EExecutionState* state, uint64_t port)
@@ -482,3 +557,45 @@ void s2e_on_monitor_event(QDict *event)
     g_s2e->getCorePlugin()->onMonitorEvent.emit(event, pluginData);
     qdict_put(event, "s2e-event", pluginData);
 }
+
+// SymDrive added this chunk / copied from llvm-lib.h (with tweaks)
+static char SymDrive_hextable[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b',
+                          'c', 'd', 'e', 'f'};
+static inline void SymDrive_uint32_to_string(uint32_t n, char *str)
+{
+    str[0] = SymDrive_hextable[(n >> 28)];
+    str[1] = SymDrive_hextable[((n >> 24) & 0xF)];
+    str[2] = SymDrive_hextable[((n >> 20) & 0xF)];
+    str[3] = SymDrive_hextable[((n >> 16) & 0xF)];
+    str[4] = SymDrive_hextable[((n >> 12) & 0xF)];
+    str[5] = SymDrive_hextable[((n >> 8) & 0xF)];
+    str[6] = SymDrive_hextable[((n >> 4) & 0xF)];
+    str[7] = SymDrive_hextable[((n >> 0) & 0xF)];
+    str[8] = 0;
+}
+
+// SymDrive added this ---------->
+void s2e_establishIOMap(int prefix, uint32_t port, uint32_t pc, uint32_t unique_id)
+{
+    std::stringstream label;
+    if (prefix == 1) {
+        label << "inb";
+    } else if (prefix == 2) {
+        label << "inw";
+    } else  if (prefix == 3) {
+        label << "inl";
+    } else {
+        assert (false && "Specify a valid prefix");
+    }
+
+    // Make the formatting identical to the one outline in op_helper.c
+    char str[9];
+    SymDrive_uint32_to_string(port, str);
+    label << str << "_";
+    SymDrive_uint32_to_string(pc, str);
+    label << str << "_";
+    SymDrive_uint32_to_string(unique_id, str);
+    label << str;
+    g_s2e->getCorePlugin()->establishIOMap(label.str());
+}
+/////////////////// <---------- SymDrive
diff --git a/qemu/s2e/Plugins/CorePlugin.h b/qemu/s2e/Plugins/CorePlugin.h
index 3d3732c..b09bfb7 100644
--- a/qemu/s2e/Plugins/CorePlugin.h
+++ b/qemu/s2e/Plugins/CorePlugin.h
@@ -65,6 +65,7 @@ typedef sigc::signal<void, S2EExecutionState*, uint64_t /* pc */> ExecutionSigna
   * This is necessary tp speedup checks (and avoid using signals) */
 typedef bool (*SYMB_PORT_CHECK)(uint16_t port, void *opaque);
 typedef bool (*SYMB_MMIO_CHECK)(uint64_t physaddress, uint64_t size, void *opaque);
+typedef bool (*ESTABLISH_IO_MAP_FN)(std::string origin, void *opaque); // SymDrive added
 
 class CorePlugin : public Plugin {
     S2E_PLUGIN
@@ -76,6 +77,10 @@ private:
     void *m_isPortSymbolicOpaque;
     void *m_isMmioSymbolicOpaque;
 
+    // SymDrive added:
+    ESTABLISH_IO_MAP_FN m_establishIOMap;
+    void *m_establishIOMapOpaque;
+
 public:
     CorePlugin(S2E* s2e): Plugin(s2e) {
         m_Timer = NULL;
@@ -83,6 +88,7 @@ public:
         m_isMmioSymbolicCb = NULL;
         m_isPortSymbolicOpaque = NULL;
         m_isMmioSymbolicOpaque = NULL;
+        m_establishIOMap = NULL; // SymDrive
     }
 
     void initialize();
@@ -98,6 +104,11 @@ public:
         m_isMmioSymbolicOpaque = opaque;
     }
 
+    void setIoMapCallback(ESTABLISH_IO_MAP_FN cb, void *opaque) { // SymDrive added this fn
+        m_establishIOMap = cb;
+        m_establishIOMapOpaque = opaque;
+    }
+
     inline bool isPortSymbolic(uint16_t port) const {
         if (m_isPortSymbolicCb) {
             return m_isPortSymbolicCb(port, m_isPortSymbolicOpaque);
@@ -112,6 +123,13 @@ public:
         return false;
     }
 
+    inline bool establishIOMap(std::string tag) const { // SymDrive added
+        if (m_establishIOMap) {
+            return m_establishIOMap(tag, m_establishIOMapOpaque);
+        }
+        return false;
+    }
+
     struct QEMUTimer *getTimer() {
         return m_Timer;
     }
@@ -187,6 +205,17 @@ public:
                  bool /* isWrite */, bool /* isIO */>
             onDataMemoryAccess;
 
+    /** Signal that is emitted on each I/O memory access */
+    // SymDrive, added this:
+    sigc::signal<void,
+        S2EExecutionState*,     /* state */
+        int,                    /* access type */
+        klee::ref<klee::Expr>,  /* virtualAddress */
+        klee::ref<klee::Expr>,  /* value */
+        int,                    /* size in bytes */
+        bool>                   /* isWrite */
+        onIOMemoryAccess;
+
     /** Signal that is emitted on each port access */
     sigc::signal<void, S2EExecutionState*,
                  klee::ref<klee::Expr> /* port */,
diff --git a/qemu/s2e/Plugins/ExecutionTracers/ExecutionTracer.cpp b/qemu/s2e/Plugins/ExecutionTracers/ExecutionTracer.cpp
index 3b5302d..df330b5 100644
--- a/qemu/s2e/Plugins/ExecutionTracers/ExecutionTracer.cpp
+++ b/qemu/s2e/Plugins/ExecutionTracers/ExecutionTracer.cpp
@@ -104,6 +104,8 @@ uint32_t ExecutionTracer::writeData(
     ExecutionTraceItemHeader item;
 
     assert(m_LogFile);
+    assert (size > 0); // SymDrive
+    assert (type < TRACE_MAX); // SymDrive
 
     item.timeStamp = llvm::sys::TimeValue::now().usec();
     item.size = size;
@@ -112,7 +114,7 @@ uint32_t ExecutionTracer::writeData(
     item.pid = state->getPid();
 
     if (fwrite(&item, sizeof(item), 1, m_LogFile) != 1) {
-        return 0;
+        assert(false); // SymDrive Was return 0
     }
 
     if (size) {
diff --git a/qemu/s2e/Plugins/ExecutionTracers/TraceEntries.h b/qemu/s2e/Plugins/ExecutionTracers/TraceEntries.h
index 04bcec9..92ce572 100644
--- a/qemu/s2e/Plugins/ExecutionTracers/TraceEntries.h
+++ b/qemu/s2e/Plugins/ExecutionTracers/TraceEntries.h
@@ -71,10 +71,81 @@ enum ExecTraceEntryType {
     TRACE_PAGEFAULT,
     TRACE_TLBMISS,
     TRACE_ICOUNT,
+    TRACE_HW_ACCESS, // SymDrive
+    TRACE_INSTR, // SymDrive
+    TRACE_BB, // SymDrive
+    TRACE_EVENT, // SymDrive
+    TRACE_SUCCESS, // SymDrive
+    TRACE_IO_REGION, // SymDrive
     TRACE_MEM_CHECKER,
     TRACE_MAX
 };
 
+// SymDrive Added this ---------------->
+enum TRACE_HW_OP {
+    TRACE_HW_PORT = 0,
+    TRACE_HW_IOMEM = 1,
+    TRACE_HW_DMA = 2
+};
+
+enum TRACE_IO_REGION {
+    IO_MAP = 0x1,
+    IO_UNMAP = 0x2,
+    PORT_MAP = 0x3,
+    PORT_UNMAP = 0x4
+};
+
+#define TRACE_HW_OP_NUM_FN 32
+#define TRACE_HW_OP_NID "Not in driver"
+struct ExecutionTraceHWAccess {
+    uint64_t          pc;
+    char              fn_names[TRACE_HW_OP_NUM_FN][32];
+    enum TRACE_HW_OP  op;
+    bool              write; // is it a write?
+    uint64_t          virt_address;
+    uint64_t          phys_address;
+    bool              address_symbolic;
+    uint64_t          value;
+    bool              value_symbolic;
+    uint8_t           size;
+    uint8_t           flags;
+} __attribute__((packed));
+
+struct ExecutionTraceInstr {
+    uint32_t          state_id;
+    uint64_t          pc;
+    uint64_t          delta;
+    char              fn[32];
+} __attribute__((packed));
+
+struct ExecutionTraceBB {
+    uint32_t          state_id;
+    uint64_t          pc;
+    uint64_t          delta;
+    char              fn[32];
+} __attribute__((packed));
+
+struct ExecutionTraceEvent {
+    uint32_t          state_id;
+    uint64_t          pc;
+    uint32_t          event;
+} __attribute__((packed));
+
+struct ExecutionTraceSuccessPath {
+    uint32_t          state_id;
+    uint64_t          pc;
+    uint64_t          success;
+    char              fn[32];
+} __attribute__((packed));
+
+struct ExecutionTraceIORegion {
+    uint32_t             state_id;
+    uint64_t             pc;
+    enum TRACE_IO_REGION flags;
+    uint32_t             address;
+    uint32_t             size;
+} __attribute__((packed));
+// SymDrive <----------------------
 
 struct ExecutionTraceItemHeader{
     uint64_t timeStamp;
diff --git a/qemu/s2e/Plugins/ModuleDescriptor.h b/qemu/s2e/Plugins/ModuleDescriptor.h
index 8defdec..8230290 100644
--- a/qemu/s2e/Plugins/ModuleDescriptor.h
+++ b/qemu/s2e/Plugins/ModuleDescriptor.h
@@ -136,6 +136,8 @@ struct ModuleDescriptor
   //A list of sections
   ModuleSections Sections;
 
+  uint32_t PrimaryModule; // SymDrive
+
   ModuleDescriptor() {
     Pid = 0;
     NativeBase = 0;
diff --git a/qemu/s2e/Plugins/RawMonitor.cpp b/qemu/s2e/Plugins/RawMonitor.cpp
index 79b3d5b..f508302 100644
--- a/qemu/s2e/Plugins/RawMonitor.cpp
+++ b/qemu/s2e/Plugins/RawMonitor.cpp
@@ -110,6 +110,13 @@ bool RawMonitor::initSection(const std::string &cfgKey, const std::string &svcId
         return false;
     }
 
+    // SymDrive added this block:
+    cfg.primaryModule = s2e()->getConfig()->getBool(cfgKey + ".primaryModule", false, &ok);
+    if (!ok) {
+        s2e()->getWarningsStream() << "You must specify " << cfgKey << "primaryModule\n";
+        return false;
+    }
+
     m_cfg.push_back(cfg);
     return true;
 }
@@ -231,6 +238,7 @@ void RawMonitor::opLoadModule(S2EExecutionState *state)
     }
 
     moduleDescriptor.Pid = moduleConfig.kernelMode ? 0 : state->getPid();
+    moduleDescriptor.PrimaryModule = moduleConfig.primaryModule; // SymDrive
 
     s2e()->getDebugStream() << "RawMonitor loaded " << moduleDescriptor.Name << " " <<
             hexval(moduleDescriptor.LoadBase) << " " << hexval(moduleDescriptor.Size) << "\n";
@@ -333,6 +341,7 @@ void RawMonitor::loadModule(S2EExecutionState *state, const Cfg &c, bool skipIfD
     md.Size = c.size;
     md.Pid = c.kernelMode ? 0 : state->getPid();
     md.EntryPoint = c.entrypoint;
+    md.PrimaryModule = c.primaryModule; // SymDrive
 
     s2e()->getDebugStream() << "RawMonitor loaded " << c.name << " " <<
             hexval(c.start) << ' ' << hexval(c.size) << '\n';
diff --git a/qemu/s2e/Plugins/RawMonitor.h b/qemu/s2e/Plugins/RawMonitor.h
index d2a2f9a..b307646 100644
--- a/qemu/s2e/Plugins/RawMonitor.h
+++ b/qemu/s2e/Plugins/RawMonitor.h
@@ -62,6 +62,7 @@ public:
         uint64_t entrypoint;
         bool delayLoad;
         bool kernelMode;
+        bool primaryModule; // SymDrive
     };
 
     struct OpcodeModuleConfig {
@@ -71,6 +72,7 @@ public:
         uint64_t entryPoint;
         uint64_t size;
         uint32_t kernelMode;
+        uint32_t primaryModule; // SymDrive
     } __attribute__((packed));
 
     typedef std::vector<Cfg> CfgList;
diff --git a/qemu/s2e/Plugins/SymDrive/MCoverageBasics.h b/qemu/s2e/Plugins/SymDrive/MCoverageBasics.h
new file mode 100644
index 0000000..e0ea9cc
--- /dev/null
+++ b/qemu/s2e/Plugins/SymDrive/MCoverageBasics.h
@@ -0,0 +1,66 @@
+#ifndef MCOVERAGE_BASICS_H
+#define MCOVERAGE_BASICS_H
+
+namespace s2etools
+{
+    struct BasicBlock
+    {
+        uint64_t timeStamp;
+        uint64_t start;
+        uint64_t end;
+        bool operator()(const BasicBlock&b1, const BasicBlock &b2) const {
+            return b1.end < b2.start;
+        }
+
+        BasicBlock(uint64_t s, uint64_t e) {
+            start = s;
+            end = e;
+            timeStamp = 0;
+        }
+
+        BasicBlock() {
+            timeStamp = 0;
+            start = end = 0;
+        }
+
+        struct SortByTime {
+
+            bool operator()(const BasicBlock&b1, const BasicBlock &b2) const {
+                if (b1.timeStamp < b2.timeStamp) {
+                    return true;
+                }
+                return b1.start < b2.start;
+            }
+        };
+    };
+
+    // Either a BB or TB depending on the context
+    struct Block
+    {
+        uint64_t timeStamp;
+        uint64_t start;
+        uint64_t end;
+
+        bool operator()(const Block&b1, const Block &b2) const {
+            return b1.start < b2.start;
+        }
+
+        Block() {
+            timeStamp = start = end = 0;
+        }
+
+        Block(uint64_t ts, uint64_t s, uint64_t e) {
+            timeStamp = ts;
+            start = s;
+            end = e;
+        }
+    };
+
+    typedef std::set<BasicBlock, BasicBlock> BasicBlocks;
+    typedef std::set<Block, Block> Blocks;
+    typedef std::set<BasicBlock, BasicBlock::SortByTime> BlocksByTime;
+    typedef std::map<std::string, BasicBlocks> Functions;
+    typedef std::map<uint64_t, std::string> BBToFunction;
+}
+
+#endif
diff --git a/qemu/s2e/Plugins/SymDrive/SymDriveSearcher.cpp b/qemu/s2e/Plugins/SymDrive/SymDriveSearcher.cpp
new file mode 100644
index 0000000..7210911
--- /dev/null
+++ b/qemu/s2e/Plugins/SymDrive/SymDriveSearcher.cpp
@@ -0,0 +1,3035 @@
+/*
+ * S2E Selective Symbolic Execution Framework
+ *
+ * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Dependable Systems Laboratory, EPFL nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE DEPENDABLE SYSTEMS LABORATORY, EPFL BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Currently maintained by:
+ *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
+ *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
+ *
+ * All contributors are listed in S2E-AUTHORS file.
+ *
+ */
+
+extern "C" {
+#include "config.h"
+#include "qemu-common.h"
+#include "qemu-timer.h"
+}
+
+#include "SymDriveSearcher.h"
+#include <llvm/Support/TimeValue.h>
+#include <s2e/S2E.h>
+#include <s2e/ConfigFile.h>
+#include <s2e/Utils.h>
+#include <s2e/S2EExecutor.h>
+#include <klee/Memory.h>
+#include <klee/Expr.h>
+
+#include <iostream>
+
+#include <llvm/Instructions.h>
+#include <llvm/Constants.h>
+#include <llvm/Function.h>
+
+// A global used in softmmu_template and softmmu_defs
+int g_tracing_enabled = 0;
+// Constant used only in this file
+static const double g_time_budget_fs = 30.0; // favor success
+static const double g_time_budget_mc = 2.0; // max coverage
+
+// #define ENABLE_INVARIANTS
+
+namespace s2e {
+namespace plugins {
+
+static bool io_map_callback (std::string tag, void *opaque);
+
+using namespace llvm;
+using namespace klee;
+
+#define MESSAGE_SL()                                    \
+    s2e()->getMessagesStream()                          \
+    << "[" << state->getID() << " / "                   \
+    << s2e()->getExecutor()->getStatesCount() << "] "   \
+    << " line: " << line << ".  "
+
+#define MESSAGE_S()                                     \
+    s2e()->getMessagesStream()                          \
+    << "[" << state->getID() << " / "                   \
+    << s2e()->getExecutor()->getStatesCount() << "] "   \
+
+#define MESSAGE() s2e()->getMessagesStream()
+
+#define WARNING_SL()                                    \
+    s2e()->getWarningsStream()                          \
+    << "[" << state->getID() << " / "                   \
+    << s2e()->getExecutor()->getStatesCount() << "] "   \
+    << " line: " << line << ".  "
+
+#define WARNING_S()                                     \
+    s2e()->getWarningsStream()                          \
+    << "[" << state->getID() << " / "                   \
+    << s2e()->getExecutor()->getStatesCount() << "] "   \
+
+#define WARNING() s2e()->getWarningsStream()
+
+
+S2E_DEFINE_PLUGIN(SymDriveSearcher, "Prioritizes states that are about to execute unexplored translation blocks",
+                  "SymDriveSearcher", "ModuleExecutionDetector");
+
+void SymDriveSearcher::initialize()
+{
+    // 
+    // Module execution
+    m_moduleExecutionDetector = static_cast<ModuleExecutionDetector*>(s2e()->getPlugin("ModuleExecutionDetector"));
+    m_searcherInited = false;
+
+    m_sorter.p = this;
+    m_states = StateSet(m_sorter);
+
+    //XXX: Take care of module load/unload
+    m_moduleExecutionDetector->onModuleTranslateBlockEnd.connect(
+            sigc::mem_fun(*this, &SymDriveSearcher::onModuleTranslateBlockEnd)
+            );
+    m_moduleExecutionDetector->onModuleTranslateBlockStart.connect(
+            sigc::mem_fun(*this, &SymDriveSearcher::onModuleTranslateBlockStart)
+            );
+
+    // Scheduling
+    s2e()->getCorePlugin()->onCustomInstruction.connect(
+        sigc::mem_fun(*this, &SymDriveSearcher::onCustomInstruction));
+    m_favorSuccessful = true;
+    m_currentTime = 1000;
+    m_lastStartTime = 0;
+    m_lastState = NULL;
+
+    // Just makes sure we select a state
+    assert (m_currentTime - m_lastStartTime > g_time_budget_fs);
+    assert (m_currentTime - m_lastStartTime > g_time_budget_mc);
+
+    s2e()->getCorePlugin()->onTimer.connect(
+        sigc::mem_fun(*this, &SymDriveSearcher::onTimer));
+
+    // Selection mode
+    m_selectionMode = 1;
+
+    // Performance analysis
+    m_dumpiomap_enabled = 0;
+    m_tracer = (ExecutionTracer*)s2e()->getPlugin("ExecutionTracer");
+    assert(m_tracer);
+    m_mon = (RawMonitor*)s2e()->getPlugin("RawMonitor");
+    assert (m_mon);
+
+    m_tb = NULL;
+    m_lastTbTraced = 0;
+    m_TrackperfIRQ = TRACKPERF_IRQ_NONE;
+
+    // Symbolic hardware
+    m_hw = (SymbolicHardware*)s2e()->getPlugin("SymbolicHardware");
+    assert (m_hw);
+    s2e()->getCorePlugin()->setIoMapCallback(io_map_callback, this);
+
+    // Basic blocks initialization:
+    initializeBB();
+
+    // Miscellaneous initialization
+    s2e()->getCorePlugin()->onStateFork.connect(
+        sigc::mem_fun(*this, &SymDriveSearcher::onFork));
+}
+
+void SymDriveSearcher::initializeBB (void) {
+    std::vector<std::string> Sections;
+    Sections = s2e()->getConfig()->getListKeys(getConfigKey());
+
+    foreach2(it, Sections.begin(), Sections.end()) {
+        MESSAGE() << "SymDriveSearcher - section " << getConfigKey() << "." << *it << '\n';
+        std::stringstream sk;
+        sk << getConfigKey() << "." << *it;
+        initSection(sk.str(), *it);
+    }
+
+    int i;
+    for (i = 0; i < m_Modules.size(); i++) {
+        ReadBBList(m_Modules[i]);
+    }
+}
+
+void SymDriveSearcher::initSection(const std::string &cfgKey, const std::string &svcId)
+{
+    bool ok;
+    std::string moduleName = s2e()->getConfig()->getString(cfgKey + ".moduleName", "", &ok);
+    if (!ok) {
+        WARNING() << "You must specify " << cfgKey <<  ".moduleName\n";
+        assert(false);
+    }
+
+    std::string moduleDir = s2e()->getConfig()->getString(cfgKey + ".moduleDir", "", &ok);
+    if (!ok) {
+        WARNING() << "You must specify " << cfgKey <<  ".moduleDir\n";
+        assert(false);
+    }
+
+    SymDriveModuleInfo newMod;
+    newMod.m_moduleName = moduleName;
+    newMod.m_moduleDir = moduleDir;
+
+    m_Modules.push_back(newMod);
+}
+
+void SymDriveSearcher::ReadBBList(SymDriveModuleInfo &module) {
+    std::string filename = module.m_moduleDir + "/" + module.m_moduleName + ".bblist";
+    FILE *fp = fopen(filename.c_str(), "r");
+    if (!fp) {
+        WARNING() << "BBLIST: Could not open file " << filename << "\n";
+        return;
+    }
+
+    MESSAGE() << "BBLIST: Opened file " << filename.c_str() << "\n";
+
+    char buffer[512];
+    while (fgets (buffer, sizeof(buffer), fp)) {
+        uint64_t start, end;
+        char name[512];
+        std::string Name;
+        char bad_block[512];
+
+        if (buffer[0] != '0' || buffer[1] != 'x') {
+            // MESSAGE() << "BBLIST: Skipping line: " << buffer << "\n";
+            continue;
+        }
+
+        buffer[strlen(buffer) - 1] = 0; // Remove \n
+
+        int args_assigned = sscanf(buffer, "0x%"PRIx64" 0x%"PRIx64" %s %[^\r\t\n]s",
+                                   &start, &end, name, bad_block);
+        if (args_assigned < 3) {
+            std::cerr << "BBLIST: Mcoverage tool - SymDrive failed to parse bblist, line is:" << std::endl;
+            std::cerr << buffer << std::endl;
+            continue;
+        }
+
+        // MESSAGE() << "BBLIST: Read 0x" << hexval(start) << " 0x" << hexval(end) << " " << name << "\n";
+        module.m_bytesTotal += end - start + 1;
+        if (args_assigned == 4) {
+            if (strcmp (bad_block, "MJR_there_is_a_gap") == 0) {
+                //std::cerr << "BBLIST: Note that we have a gap at "
+                //          << buffer << std::endl;
+                module.m_numGaps++;
+                module.m_bytesInGaps = end - start + 1;
+            } else {
+                std::cerr << "BBLIST: error reading bblist file "
+                          << buffer << std::endl;
+                assert(false);
+            }
+
+            // Option 1: Count any code executed in the gap
+            // as covering the entire gap.
+            // Option 2: Don't count any code executed in the gap
+            // as covering any of the gap.
+            // Option 2 is more conservative from a coverage perspective.
+            // But it does not make sense here.
+            // continue;
+        }
+
+        unsigned prevCount = module.m_allBbs.size();
+        std::pair<s2etools::BasicBlocks::iterator, bool> result;
+        result = module.m_allBbs.insert(s2etools::BasicBlock(start, end));
+        if (!result.second) {
+            MESSAGE() << "BBLIST: Won't insert this block.  Existing block: " << (*result.first).start << "\n";
+            continue;
+        }
+
+        // Add all instructions to Function
+        // We need mappings for all possible instruction addresses in each BB.
+        Name = name; // Use some C++ simplifications
+        for (int curAddr = start; curAddr <= end; curAddr++) {
+            module.m_AddrToFunction[curAddr] = Name;
+            if (Name.substr(0, 6) == "prefn_" ||
+                Name.substr(0, 7) == "postfn_" ||
+                Name.substr(0, 12) == "stubwrapper_") {
+                module.m_AddrValid[curAddr] = false;
+            } else {
+                module.m_AddrValid[curAddr] = true;
+            }
+        }
+
+        // Function to BBs
+        s2etools::BasicBlocks &bbs = module.m_functions[name];
+        //XXX: the +1 is here to compensate the broken extraction script, which
+        //does not take into account the whole size of the last instruction.
+        prevCount = bbs.size();
+        bbs.insert(s2etools::BasicBlock(start, end));
+        assert(prevCount == bbs.size()-1);
+
+        BBValidate(module);
+    }
+
+    BBValidate(module);
+
+    MESSAGE() << "Note that there are " << module.m_numGaps << " gaps.\n";
+
+    if (module.m_allBbs.size() == 0) {
+        MESSAGE() << "BBLIST: No BBs found in the list for " << module.m_moduleName
+                  << ". Check the format of the file.\n";
+    }
+
+    s2etools::Functions::iterator fit;
+    unsigned fcnBbCount = 0;
+    for (fit = module.m_functions.begin(); fit != module.m_functions.end() ; ++fit) {
+        fcnBbCount += (*fit).second.size();
+    }
+    assert(fcnBbCount == module.m_allBbs.size());
+    
+    fclose(fp);
+}
+
+void SymDriveSearcher::BBValidate (const SymDriveModuleInfo &module) const {
+    s2etools::Functions::const_iterator fit;
+    unsigned fcnBbCount = 0;
+    for (fit = module.m_functions.begin(); fit != module.m_functions.end() ; ++fit) {
+        fcnBbCount += (*fit).second.size();
+    }
+
+    assert(fcnBbCount == module.m_allBbs.size());
+    assert(module.m_AddrToFunction.size() == module.m_AddrValid.size());
+}
+
+std::string SymDriveSearcher::AddrToFunction (const ModuleDescriptor *md, uint64_t address) const {
+    std::vector<SymDriveModuleInfo>::const_iterator it;
+    for (it = m_Modules.begin(); it != m_Modules.end(); ++it) {
+        if (md->Name == (*it).m_moduleName) {
+            s2etools::BBToFunction::const_iterator cur = (*it).m_AddrToFunction.find(address - md->LoadBase);
+            if (cur != (*it).m_AddrToFunction.end()) {
+                const std::string candidate = (*cur).second;
+                if (candidate != "") {
+                    return candidate;
+                }
+            } else {
+                return "";
+            }
+        }
+    }
+
+    return "";
+}
+
+std::string SymDriveSearcher::AddrIsValid (const ModuleDescriptor *md, uint64_t address) const {
+    std::vector<SymDriveModuleInfo>::const_iterator it;
+    for (it = m_Modules.begin(); it != m_Modules.end(); ++it) {
+        if (md->Name == (*it).m_moduleName) {
+            std::map<uint64_t, bool>::const_iterator cur_isvalid = (*it).m_AddrValid.find(address - md->LoadBase);
+            s2etools::BBToFunction::const_iterator cur_fn = (*it).m_AddrToFunction.find(address - md->LoadBase);
+            if (cur_isvalid != (*it).m_AddrValid.end()) {
+                assert (cur_fn != (*it).m_AddrToFunction.end());
+                if ((*cur_isvalid).second) {
+                    return (*cur_fn).second;
+                }
+
+                // pre/post/stubwrapper
+                return "";
+            } else {
+                // outside module
+                return "";
+            }
+        }
+    }
+    
+    // outside module
+    return "";
+}
+
+// The idea is to initialize the SymDrive
+// searcher only after a module is loaded.
+// Before that we just use the default batching
+// searcher (S2E default policy)
+void SymDriveSearcher::initializeSearcher()
+{
+    if (m_searcherInited) {
+        return;
+    }
+
+    s2e()->getExecutor()->setSearcher(this);
+    m_searcherInited = true;
+}
+
+uint64_t SymDriveSearcher::computeTargetPc(S2EExecutionState *state)
+{
+    const Instruction *instr = state->pc->inst;
+
+    //Check whether we are the first instruction of the block
+    const BasicBlock *BB = instr->getParent();
+    if (instr != &*BB->begin()) {
+        return 0;
+    }
+
+    //There can be only one predecessor jumping to the terminating block (xxx: check this)
+    const BasicBlock *PredBB = BB->getSinglePredecessor();
+    if (!PredBB) {
+        return 0;
+    }
+
+    const BranchInst *Bi = dyn_cast<BranchInst>(PredBB->getTerminator());
+    if (!Bi) {
+        return 0;
+    }
+
+    //instr must be a call to tcg_llvm_fork_and_concretize
+    MESSAGE() << "SymDriveSearcher: " << *instr << "\n";
+
+    const CallInst *callInst = dyn_cast<CallInst>(instr);
+    if (!callInst) {
+        return 0;
+    }
+
+    assert(callInst->getCalledFunction()->getName() == "tcg_llvm_fork_and_concretize");
+
+    const ConstantInt *Ci = dyn_cast<ConstantInt>(callInst->getOperand(0)); // SymDrive changed from 1 to 0
+    if (!Ci) {
+        return false;
+    }
+
+    const uint64_t* Int = Ci->getValue().getRawData();
+    return *Int;
+    //return GetPcAssignment(BB);
+}
+
+/**
+ *  Prioritize the current state while it keeps discovering new blocks.
+ *  XXX: the implementation can add the state even if the targetpc is not reachable
+ *  because of path constraints.
+ */
+void SymDriveSearcher::onModuleTranslateBlockEnd(
+    ExecutionSignal *signal,
+    S2EExecutionState* state,
+    const ModuleDescriptor &md,
+    TranslationBlock *tb,
+    uint64_t endPc,
+    bool staticTarget,
+    uint64_t targetPc)
+{
+    initializeSearcher();
+
+    signal->connect(sigc::mem_fun(*this, &SymDriveSearcher::onTraceTbEnd));
+
+    //Done translating the blocks, no need to instrument anymore.
+    m_tb = NULL;
+    m_tbConnection.disconnect();
+}
+
+void SymDriveSearcher::onModuleTranslateBlockStart(
+    ExecutionSignal *signal,
+    S2EExecutionState *state,
+    const ModuleDescriptor &md,
+    TranslationBlock *tb,
+    uint64_t startPc)
+{
+    if (m_tb) {
+        m_tbConnection.disconnect();
+    }
+    m_tb = tb;
+
+    // trace each TB
+    signal->connect(sigc::mem_fun(*this, &SymDriveSearcher::onTraceTbStart));
+
+    // trace each instruction
+    CorePlugin *plg = s2e()->getCorePlugin();
+    m_tbConnection = plg->onTranslateInstructionStart.connect(
+        sigc::mem_fun(*this, &SymDriveSearcher::onTranslateInstructionStart));
+}
+
+// This is called during translation time
+void SymDriveSearcher::onTranslateInstructionStart(
+    ExecutionSignal *signal,
+    S2EExecutionState* state,
+    TranslationBlock *tb,
+    uint64_t pc) {
+    if (tb != m_tb) {
+        //We've been suddenly interrupted by some other module
+        m_tb = NULL;
+        m_tbConnection.disconnect();
+        return;
+    }
+
+    //connect a function that will increment the number of executed
+    //instructions.
+    signal->connect(sigc::mem_fun(*this, &SymDriveSearcher::onTraceInstruction));
+}
+
+void SymDriveSearcher::onFork(S2EExecutionState *state,
+                           const std::vector<S2EExecutionState*> &newStates,
+                           const std::vector<klee::ref<klee::Expr> > &newConditions) {
+    if (m_favorSuccessful == true) {
+        DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+        if (plgState->m_loopStates.size() > 0) {
+            unsigned int loop_count = plgState->m_loopStates.back();
+            loop_count++;
+            MESSAGE_S() << "Forking and tracking loop: " << state->getID()
+                        << ", state count: " << loop_count
+                        << ", number of entries: " << plgState->m_loopStates.size()
+                        << "\n";
+            plgState->m_loopStates.pop_back();
+            plgState->m_loopStates.push_back(loop_count);
+        }
+    }
+
+    assert(state->isActive());
+
+    //
+    // This code executes regardless of m_favorSuccessful.
+    //
+    // Delete least priority state if numbers get out of hand
+    if (m_states.size() < 100) {
+        return;
+    }
+
+    int cur_prio;
+    StateSet::iterator itAllStates;
+    S2EExecutionState *to_remove = NULL;
+    if (m_favorSuccessful == true) {
+        cur_prio = 0x7FFFFFFF;
+    } else {
+        cur_prio = 0;
+    }
+
+    // Iterate over all states.
+    for (itAllStates = m_states.begin(); itAllStates != m_states.end(); itAllStates++) {
+        S2EExecutionState *es = dynamic_cast<S2EExecutionState*>(*itAllStates);
+        // If the current state we're seeing is the current state
+        // we're executing continue and ignore it -- we never kill the
+        // current state.
+        if (es == state) {
+            continue;
+        }
+
+        // Make sure we don't kill one of the new states.
+        if (newStates.size() == 1) {
+            // Simple common case: forking only one other path
+            if (es == newStates[0]) {
+                continue;
+            }
+        } else if (newStates.size() > 1) {
+            // Complex case where we're forking
+            // multiple branches
+            bool exists = false;
+            std::vector<S2EExecutionState *>::const_iterator itNewStates;
+            for (itNewStates = newStates.begin();
+                 itNewStates != newStates.end();
+                 itNewStates++) {
+                S2EExecutionState *newState = *itNewStates;
+                if (newState == es) {
+                    exists = true;
+                    break;
+                }
+            }
+
+            if (exists) {
+                continue;
+            }
+        } else {
+            assert (false && "newStates.size() == 0");
+        }
+
+        // Only choose the state for removal if it's not one of the new ones
+        // We need this complex test because S2E chokes and dies otherwise.
+        DECLARE_PLUGINSTATE(SymDriveSearcherState, es);
+        if (m_favorSuccessful == true) {
+            if (plgState->m_priorityChange < cur_prio) {
+                cur_prio = plgState->m_priorityChange;
+                to_remove = es;
+            }
+        } else {
+            // Favor successful = false should work too.
+            // TODO make this more comprehensive -- why is this
+            // a low priority state?
+            if (plgState->m_metricValid &&
+                plgState->m_metric > cur_prio) {
+                cur_prio = plgState->m_metric;
+                to_remove = es;
+            }
+        }
+    }
+
+    if (to_remove != NULL) {
+        assert(to_remove->isActive() == false);
+        WARNING() << "Destroying state "
+                  << to_remove->getID()
+                  << ", prio: " << cur_prio << "\n";
+        helper_check_invariants(true);
+        s2e()->getExecutor()->terminateStateEarly(*to_remove, "Too many states -- killing low priority one");
+        helper_check_invariants(true);
+    } else {
+        WARNING() << "Failed to destroy any state" << "\n";
+    }
+}
+
+void SymDriveSearcher::onCustomInstruction(S2EExecutionState* state, uint64_t opcode)
+{
+    uint8_t opc = (opcode>>8) & 0xFF;
+    if (opc < 0xB3 || opc > 0xCB) {
+        // Outside range of supported opcodes
+        return;
+    }
+
+    int line = 0;
+    bool ok = true;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EAX]),
+                                         &line, 4);
+    if (!ok) {
+        WARNING_S()
+            << "ERROR: symbolic argument was passed to SymDriveSearcher "
+            " insert_symbolic opcode" << "\n";
+    }
+
+    assert(state->isActive () == true);
+    helper_check_invariants (true);
+    m_states.erase(state);
+    helper_check_state_not_exists(state);
+    helper_check_invariants (true);
+
+    // We do + 1 on all m_states.size() operations below
+    // to compensate for temporary state removal.
+
+    switch (opc) {
+        // 0xb1 = make dma memory
+        // 0xb2 = free dma memory
+        case 0xB3: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_prioritize(state, plgState, line);
+            break;
+        }
+        case 0xB4: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_deprioritize(state, plgState, line);
+            break;
+        }
+        case 0xB5: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_loop_before(state, plgState, line);
+            break;
+        }
+        case 0xB6: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_loop_body(state, plgState, line);
+            break;
+        }
+        case 0xB7: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_loop_after(state, plgState, line);
+            break;
+        }
+        case 0xB8: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_concretize_kill(state, plgState, line);
+            break;
+        }
+        case 0xB9: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_concretize_all(state, plgState, line);
+            break;
+        }
+        case 0xBA: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_kill_all_others(state, plgState, line);
+            break;
+        }
+        case 0xBB: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_driver_call_stack(state, plgState, line);
+            break;
+        }
+        case 0xBC: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_favor_successful(state, plgState, line);
+            break;
+        }
+        // hole
+        case 0xBE: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_reset_priorities(state, plgState, line);
+            break;
+        }
+        // hole
+        case 0xC0: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_enable_tracing(state, plgState, line);
+            break;
+        }
+
+        case 0xC1: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_disable_tracing(state, plgState, line);
+            break;
+        }
+
+        case 0xC2: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_enter_function(state, plgState, line);
+            break;
+        }
+
+        case 0xC3: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_exit_function(state, plgState, line);
+            break;
+        }
+
+        case 0xC4: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_is_symbolic_symdrive(state, plgState, line);
+            break;
+        }
+
+        case 0xC5: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_success_path(state, plgState, line);
+            break;
+        }
+
+        case 0xC6: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_enter_block(state, plgState, line);
+            break;
+        }
+
+        case 0xC7: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_primary_fn(state, plgState, line);
+            break;
+        }
+
+        case 0xC8: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_enable_trackperf(state, plgState, line);
+            break;
+        }
+
+        case 0xC9: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_disable_trackperf(state, plgState, line);
+            break;
+        }
+
+        case 0xCA: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_trackperf_fn(state, plgState, line);
+            break;
+        }
+
+        case 0xCB: {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+            s2e_io_region(state, plgState, line);
+            break;
+        }
+
+        default:
+            assert (false);
+    }
+
+    m_states.insert(state);
+    helper_check_invariants (true);
+}
+
+void SymDriveSearcher::s2e_prioritize (S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    if (m_favorSuccessful == false) {
+        assert (plgState->m_priorityChange <= 0);
+        assert (plgState->m_loopStates.size() == 0);
+        return;
+    }
+
+    // s2e_prioritize
+    if (plgState->m_priorityChange >= -PRIORITY_FIDDLE) {
+        if (plgState->m_priorityChange <= PRIORITY_EXTREME) {
+            plgState->m_priorityChange += PRIORITY_FIDDLE;
+        } else {
+            assert (false && "Really?");
+        }
+        // Else do nothing since we have a big boost
+    } else {
+        // Immediately reset it so that a built-up penalty won't hose
+        // us forever
+        plgState->m_priorityChange = 0;
+    }
+
+    // MESSAGE_SL() << "Prioritizing" << "\n";
+}
+
+//
+// TODO: We really want this function to reschedule immediately
+// That is, no further instructions.  See end of function body
+// for more information
+//
+void SymDriveSearcher::s2e_deprioritize(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    if (m_favorSuccessful == false) {
+        assert (plgState->m_priorityChange <= 0);
+        assert (plgState->m_loopStates.size() == 0);
+        return;
+    }
+
+    if (line < 0) {
+        line = -line;
+
+        // Subtract until we're not in first place any more.
+        StateSet::iterator itAllStates;
+        int target_priority = INT_MIN;
+        if (m_states.size() > 1) {
+            for (itAllStates = m_states.begin(); itAllStates != m_states.end(); itAllStates++) {
+                S2EExecutionState *es = dynamic_cast<S2EExecutionState*>(*itAllStates);
+                // If the current state we're seeing is the current state
+                // we're executing continue and ignore it
+                if (es == state) {
+                    continue;
+                }
+
+                DECLARE_PLUGINSTATE(SymDriveSearcherState, es);
+                if (target_priority < plgState->m_priorityChange) {
+                    target_priority = plgState->m_priorityChange;
+                }
+            }
+
+            int delta = plgState->m_priorityChange - target_priority;
+
+            if (delta >= 0) {
+                // delta == 0 means we have a tie for first place.
+                // Always subtract at least one in that case.
+                // Also, subtract one more to be sure this state doesn't
+                // end up equal in priority to the next
+                delta++;
+                plgState->m_priorityChange -= delta;
+                MESSAGE_S() << "Deprioritizing by " << delta << " at line " << line << "\n";
+            } else {
+                // This should not happen -- the currently executing state
+                // should be in first place, but this might occur because
+                // rescheduling is not instantaneous.
+                // If we could force a resechedule immediately we could
+                // add an "assert (false);" here.
+                // See "throw CpuExitException();"
+                WARNING_S() << "Deprioritizing - already not in first place?  Line "
+                            << line << "\n";
+            }
+        } else {
+            MESSAGE_S() << "Deprioritizing - not bothering as only one state is available.  Line "
+                        << line << "\n";
+        }
+    } else if (line == 0) {
+        // Force it to be awful.
+        plgState->m_priorityChange = -PRIORITY_FIDDLE;
+        MESSAGE_S() << "Deprioritizing by force: " << -PRIORITY_FIDDLE << "\n";
+    } else {
+        // This feature reduces the amount of the penalty for a given line over time
+        // The idea is that we decrease the amount of penalty with each subsequent
+        // penalty, until we hit a minimum, at which point we just don't bother
+        // penalizing further since it's evident that it's not doing any good anyway.
+
+        /*
+        if (m_currentPenalty.find (line) == m_currentPenalty.end()) {
+            m_currentPenalty[line] = MAX_PENALTY;
+            plgState->m_priorityChange = -PRIORITY_FIDDLE;
+            MESSAGE_SL() << "Deprioritizing by force: " << -PRIORITY_FIDDLE << "\n";
+        } else {
+            if (m_currentPenalty[line] > 0) {
+                if (plgState->m_priorityChange > 0) {
+                    plgState->m_priorityChange /= m_currentPenalty[line];
+                }
+                m_currentPenalty[line] /= 2;
+                MESSAGE_SL() << "Deprioritizing by: " << m_currentPenalty[line] << "\n";
+            } else {
+                MESSAGE_SL() << "Deprioritizing:  letting through failed state.\n";
+                // Maybe don't reset?  This kind of issue indicates a problem anyway.
+                // m_currentPenalty[line] = MAX_PENALTY; // reset
+            }
+        }
+        */
+
+        /*
+          The trouble with that feature is that it lets through failed states
+          occasionally.  There is no way to bypass it, so let's revert to
+          forcible deprioritization and warn if it gets stuck
+        */
+
+        if (m_currentPenalty.find (line) == m_currentPenalty.end()) {
+            m_currentPenalty[line] = MAX_PENALTY;
+            plgState->m_priorityChange = -PRIORITY_FIDDLE;
+            MESSAGE_SL() << "Deprioritizing: " << -PRIORITY_FIDDLE << "\n";
+        } else {
+            if (m_currentPenalty[line] > 0) {
+                m_currentPenalty[line]--;
+                MESSAGE_SL() << "Deprioritizing: " << -PRIORITY_FIDDLE << "\n";
+            } else {
+                WARNING_SL() << "Deprioritizing warning:  repeated deprioritizations, maybe add annotation?\n";
+            }
+
+            plgState->m_priorityChange = -PRIORITY_FIDDLE;
+        }
+    }
+
+    MESSAGE_SL() << "Rescheduling..." << "\n";
+    // Add back state
+    // Otherwise we'll never reschedule back to it.
+    m_states.insert(state);
+    helper_check_invariants(true);
+    state->writeCpuState(CPU_OFFSET(eip), state->getPc() + 10, 32);
+    m_lastState = NULL;
+
+    // Revision 8,204:
+    s2e()->getExecutor()->yieldState(*state);
+
+    // Let's try again:
+    //state->setRescheduling(true);
+
+    // force reschedule
+    //state->writeCpuState(CPU_OFFSET(exception_index), EXCP_S2E, 8*sizeof(int));
+    //throw CpuExitException();
+
+    // Don't call directly:
+    // s2e()->getExecutor()->stateSwitchTimerCallback(s2e()->getExecutor());
+    // qemu_mod_timer(s2e()->getExecutor()->m_stateSwitchTimer, 0); // Fire as fast as possible.
+
+    // We're rescheduling but not immediately :(  TODO add feature
+    // to reschedule immediately (no more instructions on current path)
+    // ::usleep(100 * 1000); // Maybe this will do the job? Heh
+    // See m_stateSwitchTimer and sleep same amt in ms.
+}
+
+void SymDriveSearcher::s2e_loop_before(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    if (m_favorSuccessful == false) {
+        assert (plgState->m_priorityChange <= 0);
+        assert (plgState->m_loopStates.size() == 0);
+        return;
+    }
+
+    int call_id = helper_readCallId(state, plgState);
+
+    // Path-specific:
+    plgState->m_loopStates.push_back(0);
+
+    // Note that this code applies to all paths:
+    if (m_loopCount.find(call_id) == m_loopCount.end()) {
+        m_loopCount[call_id] = 0;
+    } else {
+        // Some path is hitting the same loop.
+    }
+
+    MESSAGE_SL() << "Before loop, call_id: " << call_id << "\n";
+}
+
+void SymDriveSearcher::s2e_loop_body(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    if (m_favorSuccessful == false) {
+        assert (plgState->m_priorityChange <= 0);
+        assert (plgState->m_loopStates.size() == 0);
+        return;
+    }
+
+    int call_id = helper_readCallId(state, plgState);
+    assert (plgState->m_loopStates.size () > 0);
+
+    // Notice that we're executing a loop now.
+    // We may increment this repeatedly along different paths.
+    m_loopCount[call_id]++;
+
+    // We want to find any state that keeps forking more copies
+//    if (m_states.size() + 1 < plgState->m_loopStates.back()) {
+//        // In this case, we must have been generating states,
+//        // and then we killed a bunch.
+//       // Do nothing?  Forking is disabled -- see below.
+//        return;
+//    }
+
+    if (plgState->m_loopStates.back() == 0) {
+        //MESSAGE() << "Loop is not generating states, state: " << state->getID()
+        //                        << ", line " << line << "\n";
+        // In this case there was no change.
+        // Prioritize so we don't lose out.
+        s2e_prioritize(state, plgState, line);
+        return;
+    }
+
+    if (plgState->m_loopStates.back() >= 1 &&
+        plgState->m_loopStates.back() <= 20) {
+        // In this case, we're generating states but have not generated that many
+        MESSAGE_SL() << "Loop generating states, call_id: " << call_id << "\n";
+
+        assert (m_loopCount[call_id] >= 0);
+
+        if (m_loopCount[call_id] == 1) {
+            // We've executed one interation of the loop along this path
+            // We might fall through at this point, e.g. if it's a polling
+            // loop.  Let's do nothing and see.
+        } else if (m_loopCount[call_id] == 2) {
+            // Deprioritize a lot
+            s2e_deprioritize(state, plgState, 0);
+        } else if (m_loopCount[call_id] == 3) {
+            // Deprioritize only a bit since we've executed
+            // this loop three times -- we're really hoping now
+            s2e_deprioritize(state, plgState, -line);
+        } else {
+            // If it's greater, prioritize and hope
+            s2e_prioritize(state, plgState, line);
+        }
+        return;
+    }
+
+    if (plgState->m_loopStates.back() > 20) {
+        // In this case, each iteration of the loop is growing the number
+        // of states.  That's bad.  Deprioritize
+        // Actually, just kill it.
+        // s2e_deprioritize(state, plgState, line);
+
+        if (plgState->m_loopStates.back() % 10 == 0) {
+            WARNING() << "Loop generating many states, state: " << state->getID()
+                      << ", call_id: " << call_id
+                      << ", line: " << line
+                      << ", count: " << plgState->m_loopStates.back()
+                      << "\n";
+            WARNING() << "Attempting deprioritize...\n";
+            s2e_deprioritize(state, plgState, -line);
+        } else {
+            s2e_prioritize(state, plgState, line);
+        }
+        return;
+    }
+
+    assert(false);
+}
+
+void SymDriveSearcher::s2e_loop_after(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    if (m_favorSuccessful == false) {
+        assert (plgState->m_priorityChange <= 0);
+        assert (plgState->m_loopStates.size() == 0);
+        return;
+    }
+
+    int call_id = helper_readCallId(state, plgState);
+    if (plgState->m_loopStates.size() == 0) {
+        MESSAGE_SL() << "Failure: line " << line << ", call_id = " << call_id << "\n";
+        assert (false && "Should have already set loopStates");
+    }
+    plgState->m_loopStates.pop_back();
+
+    // TODO: Do we need this call:
+    // Reasoning about this variable across states is complex
+    // because:
+    // 1) Nested loops exist
+    // 2) Multiple invocations of the same loop exist
+    // 3) A path that successfully makes it through a loop may
+    //    be deprioritized and end up back in it.
+
+    /*int result = */m_loopCount.erase(call_id);
+
+    // TODO:
+    // This assertion is not needed, I think.  The idea is that
+    // a path may fork off some copies, then finish the loop, then
+    // end up back in the loop when S2E switches
+    // assert(result == 1 && "Loop not started?");
+
+    s2e_prioritize(state, plgState, line);
+    MESSAGE_SL() << "After loop, call_id: " << call_id << "\n";
+}
+
+void SymDriveSearcher::s2e_concretize_kill (S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    if (m_favorSuccessful == false) {
+        assert (plgState->m_priorityChange <= 0);
+        assert (plgState->m_loopStates.size() == 0);
+        return;
+    }
+
+    // Concretize everything
+    s2e_concretize_all(state, plgState, line);
+    // Prioritize ourselves
+    s2e_prioritize(state, plgState, line);
+
+    if (plgState->m_driverCallStack > 0) {
+        MESSAGE_SL() << "s2e_concretize_kill called, but m_driverCallStack = "
+                  << plgState->m_driverCallStack << "\n";
+        return;
+    }
+
+    // Kill other states
+    s2e_kill_all_others (state, plgState, line);
+}
+
+void SymDriveSearcher::s2e_concretize_all (S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    StateSet::iterator it;
+    MESSAGE_SL() << "Concretizing everything, maybe?" << "\n";
+    MESSAGE_SL() << "Switching to concrete execution at pc = "
+              << hexval(state->getPc()) << "\n";
+
+    /* Concretize any symbolic registers */
+    MESSAGE_SL() << "Concretizing everything (except registers!??  ks8851 workaround)... " << "\n";
+
+    // Concretize everything
+    state->addressSpace.concretizeAll(s2e()->getExecutor());
+}
+
+void SymDriveSearcher::s2e_kill_all_others (S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    // Only remove other states if we're not being reentrant.
+    MESSAGE_SL() << "Removing all other states, count: " << m_states.size() << "\n";
+
+    // Retrieve all states -- this plugin does not normally track a number of other states.
+    StateSet::iterator itAllStates;
+    for (itAllStates = m_states.begin(); itAllStates != m_states.end(); itAllStates++) {
+        S2EExecutionState *es = dynamic_cast<S2EExecutionState*>(*itAllStates);
+        if (es != state) {
+            s2e()->getExecutor()->terminateStateEarly
+                (*es, "Killed because we're removing all states except one");
+        } else {
+            WARNING() << "Not killing current state: " << es->getID() << "\n";
+        }
+    }
+
+    // We re-add state after end of opcode switch statement.
+    m_states.clear();
+    helper_check_invariants(true);
+}
+
+void SymDriveSearcher::s2e_driver_call_stack (S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    int driver_call_stack = 0;
+    bool ok = true;
+
+    // Execute this function regardless of m_favorSuccessful
+    // since this way the value will be all set if we switch back
+
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                         &driver_call_stack, 4);
+    if (!ok) {
+        WARNING_S() << "ERROR: symbolic argument was passed to " << __func__ << "\n";
+    }
+
+    plgState->m_driverCallStack = driver_call_stack;
+}
+
+void SymDriveSearcher::s2e_favor_successful (S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    int successful = 0;
+    bool ok = true;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                         &successful, 4);
+    if (!ok) {
+        WARNING_S() << "ERROR: symbolic argument was passed to " << __func__ << "\n";
+    }
+
+    if (successful == 0) {
+        if (m_favorSuccessful == true) {
+            m_favorSuccessful = false;
+            WARNING_S() << "s2e_favor_successful: false" << "\n";
+
+            // Now, we're no longer favoring successful states, so we need to back out
+            // all the priority hacking crap we've been doing.
+            s2e_reset_priorities(state, plgState, line);
+
+            // ethtool functions don't really need this
+            // but sometimes we do.
+            // s2e_kill_all_others(state, plgState, line);
+        }
+        // else do nothing -- this is a no-op.
+    } else {
+        // This has really weird semantics and it's not clear when we'd ever
+        // want to set it to false and then subsequently re-enable it along
+        // this branch.
+        //
+        // TODO: Can we do anything interesting along this branch?
+        //
+        WARNING_S() << "s2e_favor_successful: true" << "\n";
+        m_favorSuccessful = true;
+    }
+}
+
+void SymDriveSearcher::s2e_reset_priorities(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    // Reset all statistics
+    WARNING_S() << "s2e_reset_priorities:  resetting priorities to 0" << "\n";
+    StateSet::iterator itAllStates;
+
+    helper_check_invariants(true);
+    m_states.insert(state);
+    helper_check_invariants(true);
+    std::set<klee::ExecutionState*> states_copy;
+    for (itAllStates = m_states.begin(); itAllStates != m_states.end(); itAllStates++) {
+        S2EExecutionState *es = dynamic_cast<S2EExecutionState*>(*itAllStates);
+        DECLARE_PLUGINSTATE(SymDriveSearcherState, es);
+        plgState->m_priorityChange = 0;
+        plgState->m_loopStates.clear();
+
+        states_copy.insert(es);
+    }
+
+    // We need to reset our set
+    WARNING_S() << "s2e_favor_successful:  re-adding all states..." << "\n";
+
+    // Re-set all states:
+    std::set<klee::ExecutionState*> empty_set;
+    m_states.clear();
+    helper_check_invariants(true);
+    update (state, states_copy, empty_set);
+}
+
+void SymDriveSearcher::s2e_enable_tracing(S2EExecutionState *state, SymDriveSearcherState* plgState, int line)
+{
+    MESSAGE_SL() << "Enabling I/O memory tracing" << "\n";
+    g_tracing_enabled = 1;
+    m_memoryMonitor.disconnect();
+    m_memoryMonitor = s2e()->getCorePlugin()->onIOMemoryAccess.connect(
+        sigc::mem_fun(*this, &SymDriveSearcher::onIOMemoryAccess));
+}
+
+void SymDriveSearcher::s2e_disable_tracing(S2EExecutionState *state,
+                                        SymDriveSearcherState* plgState,
+                                        int line)
+{
+    MESSAGE_SL() << "Disabling I/O memory tracing" << "\n";
+    m_memoryMonitor.disconnect();
+    g_tracing_enabled = 0;
+}
+
+void SymDriveSearcher::s2e_enterexit_function(S2EExecutionState *state,
+                                           SymDriveSearcherState* plgState,
+                                           int line,
+                                           bool enter) {
+    uint32_t fn_address; // 32-bit only
+    bool ok = state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                             &fn_address, 4);
+    if(!ok) {
+        WARNING_S() << "ERROR: symbolic argument was passed to s2e_enter_function 1." << "\n";
+        return;
+    }
+
+    std::string fn = "";
+    if(!state->readString(fn_address, fn)) {
+        WARNING_S() << "Error reading s2e_enter_function param" << "\n";
+        return;
+    }
+
+//    enum symdrive_WRAPPER_TYPE // Must match test framework definition
+//    {
+//        STUBWRAPPER = 0,
+//        PREPOSTFN = 1
+//    };
+
+    int wrapper_type;
+    ok = state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_ECX]),
+                                        &wrapper_type, 4);
+    if(!ok) {
+        WARNING_S() << "ERROR: symbolic argument was passed to s2e_enter_function 2." << "\n";
+        return;
+    }
+
+    if (wrapper_type == 0) { // stubwrapper
+        if (enter == false) {
+            helper_push_driver_call_stack(state, plgState, fn, line);
+        } else {
+            helper_pop_driver_call_stack(state, plgState, fn, line);
+        }
+
+        m_FunctionCounts[fn]++; // Keep track of global function counts
+    } else { // driver function
+        if (enter == true) {
+            helper_push_driver_call_stack(state, plgState, fn, line);
+        } else {
+            helper_pop_driver_call_stack(state, plgState, fn, line);
+        }
+    }
+}
+
+void SymDriveSearcher::s2e_enter_function(S2EExecutionState *state,
+                                       SymDriveSearcherState* plgState,
+                                       int line)
+{
+    s2e_enterexit_function(state, plgState, line, true);
+}
+
+void SymDriveSearcher::s2e_exit_function(S2EExecutionState *state,
+                                      SymDriveSearcherState* plgState,
+                                      int line)
+{
+    s2e_enterexit_function(state, plgState, line, false);
+}
+
+void SymDriveSearcher::s2e_is_symbolic_symdrive(S2EExecutionState *state,
+                                                SymDriveSearcherState* plgState,
+                                                int line)
+{
+    ref<Expr> expr = state->readCpuRegister(CPU_OFFSET(regs[R_EBX]),
+                                            4 * 8); // 4 bytes = good enough
+    uint32_t v = 0;
+    if(!isa<klee::ConstantExpr>(expr)) {
+        // false = not concrete
+        v = 1;
+    } else {
+        v = 0;
+    }
+
+    state->writeCpuRegisterConcrete(CPU_OFFSET(regs[R_EAX]), &v, 4);
+}
+
+void SymDriveSearcher::s2e_success_path(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    uint32_t fn_address; // 32-bit only
+    int success_path = 0;
+    bool ok;
+
+    // This code executes regardless of m_favorSuccessful
+    ok = state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                        &fn_address, 4);
+    if(!ok) {
+        WARNING_S() << "ERROR: symbolic argument was passed to s2e_success_path 1." << "\n";
+        return;
+    }
+
+    ok = state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_ECX]),
+                                        &success_path, 4);
+
+    assert (success_path >= -1 && success_path <= 1);
+
+    std::string fn = "";
+    if(!state->readString(fn_address, fn)) {
+        WARNING_S() << "Error reading s2e_success_path param 2" << "\n";
+        return;
+    }
+
+    if (success_path == 1) {
+        if (plgState->m_successPath >= 0) {
+            plgState->m_successPath += success_path;
+        } else {
+            // Once failed - always failed
+            plgState->m_successPath -= success_path;
+        }
+    } else if (success_path == -1) {
+        plgState->m_successPath += success_path;
+        // Once failed - always failed.
+    } else if (success_path == 0) {
+        plgState->m_successPath = 0;
+    } else {
+        assert (false && "Add or subtract 1 for success_path, or reset with 0");
+    }
+
+    helper_ETraceSuccess(state, fn, plgState->m_successPath);
+}
+
+void SymDriveSearcher::s2e_enter_block(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    bool ok = true;
+    uint32_t str_address;
+    int total_blocks;
+    int cur_block;
+
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                         &str_address, 4);
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_ECX]),
+                                         &total_blocks, 4);
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EDX]),
+                                         &cur_block, 4);
+    if (!ok) {
+        WARNING() << "Check s2e_enter_block call: "
+                                   << total_blocks
+                                   << ", cur: "
+                                   << cur_block
+                                   << "\n";
+        assert(false);
+    }
+
+    std::string function = "";
+    if(!state->readString(str_address, function)) {
+        WARNING_S() << "Error reading s2e_enter_block param" << "\n";
+        return;
+    }
+
+    // DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+    m_BlockCounts[function].function = function;
+    m_BlockCounts[function].total_blocks = total_blocks;
+    m_BlockCounts[function].blocks_touched[cur_block] = true;
+
+/*
+    MESSAGE_SL() << "Function: " << function << ", "
+              << "Total blocks: " << total_blocks << ", "
+              << "Current block: " << cur_block
+              << "\n";
+*/
+}
+
+void SymDriveSearcher::s2e_primary_fn(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    bool ok = true;
+    uint32_t str_address;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                         &str_address, 4);
+    std::string function = "";
+    if(!state->readString(str_address, function)) {
+        WARNING_S() << "Error reading s2e_primary_fn param" << "\n";
+        return;
+    }
+
+    if (function.size() == 0) {
+        MESSAGE_SL() << "Not adding primary function because it's empty" << "\n";
+        return;
+    }
+
+    MESSAGE_SL() << "Adding primary function: " << function << "\n";
+    m_PrimaryFn.push_back(function);
+}
+
+void SymDriveSearcher::s2e_enable_trackperf(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    int op;
+    bool ok = state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]), &op, 4);
+    if (!ok) {
+        WARNING()
+            << "Check s2e_enable_trackperf line "
+            << line << "\n";
+        assert(false);
+    }
+
+    std::string push_pop = "ERROR";
+    switch (op) {
+        case START_AUTO:
+        case START_MANUAL:
+            push_pop = "PUSH";
+            break;
+
+        case CONTINUE_PP:
+        case CONTINUE_STUB:
+        case CONTINUE_IRQ:
+        case CONTINUE_AUTO:
+        case CONTINUE_MANUAL:
+            push_pop = "POP";
+            break;
+
+        // Special cases:  These are more like runtime parameters
+        case TRACKPERF_IRQ_ALL:
+            MESSAGE_SL() << "Trackperf:  TRACKPERF_IRQ_ALL\n";
+            m_TrackperfIRQ = TRACKPERF_IRQ_ALL;
+            return;
+        case TRACKPERF_IRQ_ONLY_CALLED:
+            MESSAGE_SL() << "Trackperf:  TRACKPERF_IRQ_ONLY_CALLED\n";
+            m_TrackperfIRQ = TRACKPERF_IRQ_ONLY_CALLED;
+            return;
+        case TRACKPERF_IRQ_NONE:
+            MESSAGE_SL() << "Trackperf:  TRACKPERF_IRQ_NONE\n";
+            m_TrackperfIRQ = TRACKPERF_IRQ_NONE;
+            return;
+
+        // Anything else is nonsense in this context:
+        default:
+            MESSAGE_SL() <<" Trackperf failure: " << op << "\n";
+            assert (false);
+    }
+
+    if (push_pop == "PUSH") {
+        assert (plgState->m_TrackPerf.size() <= 100);
+        plgState->m_TrackPerf.push_back(op);
+    } else if (push_pop == "POP") {
+        int size = plgState->m_TrackPerf.size();
+        if (size < 1) {
+            MESSAGE_SL() << "Trying to pop nonexistent state.  Line: " << line << ", op: " << op << "\n";
+            assert (false);
+        }
+
+        int correspondence = 0;
+        if (op == CONTINUE_PP) correspondence = PAUSE_PP;
+        if (op == CONTINUE_STUB) correspondence = PAUSE_STUB;
+        if (op == CONTINUE_IRQ) correspondence = PAUSE_IRQ;
+        if (op == CONTINUE_AUTO) correspondence = PAUSE_AUTO;
+        if (op == CONTINUE_MANUAL) correspondence = PAUSE_MANUAL;
+        assert (correspondence);
+
+        int i;
+        bool removed = false;
+        for (i = size - 1;
+             i >= 0;
+             i--) {
+            if (plgState->m_TrackPerf[i] == correspondence) {
+                plgState->m_TrackPerf.erase(plgState->m_TrackPerf.begin() + i);
+                removed = true;
+                break;
+            }
+        }
+
+        assert (removed);
+    } else {
+        assert (false);
+    }
+
+    std::string list = "";
+    list += helper_dump_trackperf(state, plgState->m_TrackPerf);
+    helper_ETraceEvent(state, op);
+    // MESSAGE_SL() << "Enabling performance tracking (" << op << ").  " << list << "\n";
+}
+
+void SymDriveSearcher::s2e_disable_trackperf(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    int op;
+    bool ok = state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]), &op, 4);
+    if (!ok) {
+        WARNING() << "Check s2e_disable_trackperf line "
+                                   << line
+                                   << "\n";
+        assert(false);
+    }
+
+    std::string push_pop = "ERROR";
+    switch (op) {
+        case (PAUSE_PP):
+        case (PAUSE_STUB):
+        case (PAUSE_IRQ):
+        case (PAUSE_AUTO):
+        case (PAUSE_MANUAL):
+            push_pop = "PUSH";
+            break;
+
+        case (STOP_AUTO):
+        case (STOP_MANUAL):
+        case (DISCARD_AUTO):
+        case (DISCARD_MANUAL):
+            push_pop = "POP";
+            break;
+
+        default:
+            assert (false);
+    }
+
+    if (push_pop == "PUSH") {
+        // Disable tracking for now.
+        plgState->m_TrackPerf.push_back(op);
+    } else if (push_pop == "POP") {
+        int size = plgState->m_TrackPerf.size();
+        assert (size >= 1);
+
+        int correspondence = 0;
+        if (op == STOP_AUTO) correspondence = START_AUTO;
+        if (op == DISCARD_AUTO) correspondence = START_AUTO;
+        if (op == STOP_MANUAL) correspondence = START_MANUAL;
+        if (op == DISCARD_MANUAL) correspondence = START_MANUAL;
+        assert (correspondence);
+
+        int i;
+        bool removed = false;
+        for (i = size - 1;
+             i >= 0;
+             i--) {
+            if (plgState->m_TrackPerf[i] == correspondence) {
+                plgState->m_TrackPerf.erase(plgState->m_TrackPerf.begin() + i);
+                removed = true;
+                break;
+            }
+        }
+
+        assert (removed);
+    } else if (push_pop == "CLEAR") {
+        plgState->m_TrackPerf.clear();
+    } else {
+        assert (false);
+    }
+
+    //MESSAGE_SL() << "Disabling performance tracking (" << op << ").  "
+    //             << helper_dump_trackperf(state, plgState->m_TrackPerf) << "\n";
+
+    if (op == STOP_AUTO || op == STOP_MANUAL) {
+        helper_perf_store(state, plgState);
+        MESSAGE() << helper_dump_allperf(state);
+    }
+
+    if (op == STOP_AUTO || op == STOP_MANUAL || op == DISCARD_AUTO || op == DISCARD_MANUAL) {
+        helper_perf_reset(state, plgState);
+    }
+
+    helper_ETraceEvent(state, op);
+}
+
+void SymDriveSearcher::s2e_trackperf_fn(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    bool ok = true;
+    uint32_t str_address;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                         &str_address, 4);
+    std::string function = "";
+    if(!state->readString(str_address, function)) {
+        WARNING_S() << "Error reading s2e_trackperf_fn param" << "\n";
+        return;
+    }
+
+    if (function.size() == 0) {
+        MESSAGE_SL() << "Not adding trackperf function because it's empty" << "\n";
+        return;
+    }
+
+    uint32_t flags;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_ECX]),
+                                         &flags, 4);
+    
+    MESSAGE_SL() << "Adding trackperf function: " << function << ", flags " << flags << "\n";
+    m_TrackperfFn.push_back(function);
+    m_TrackperfFnFlags.push_back(flags);
+    assert (flags == TRACKPERF_NONTRANSITIVE ||
+            flags == TRACKPERF_TRANSITIVE ||
+            flags == TRACKPERF_IRQ_HANDLER);
+    assert (m_TrackperfFn.size() == m_TrackperfFnFlags.size());
+}
+
+void SymDriveSearcher::s2e_io_region(S2EExecutionState *state, SymDriveSearcherState* plgState, int line) {
+    bool ok = true;
+    uint32_t flags;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                         &flags, 4);
+    uint32_t address;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_ECX]),
+                                         &address, 4);
+    uint32_t size;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EDX]),
+                                         &size, 4);
+
+    assert (flags == s2e::plugins::IO_MAP ||
+            flags == s2e::plugins::IO_UNMAP ||
+            flags == s2e::plugins::PORT_MAP ||
+            flags == s2e::plugins::PORT_UNMAP);
+    assert (ok && "Make sure s2e_io_region is used properly.  Who needs documentation when you have assert?");
+
+    MESSAGE_SL() << "s2e_io_region. line: " << line <<
+        ", flags: " << flags <<
+        ", address: " << hexval(address) <<
+        ", size: " << hexval(size) <<
+        "\n";
+
+    // Using S2E trace infrastructure too
+    ExecutionTraceIORegion e;
+    memset(&e, 0, sizeof(e));
+    e.state_id = state->getID();
+    e.pc = state->getPc();
+    e.flags = (enum s2e::plugins::TRACE_IO_REGION) flags;
+    e.address = address;
+    e.size = size;
+    m_tracer->writeData(state, &e, sizeof(e), TRACE_IO_REGION);
+}
+
+#ifdef ENABLE_INVARIANTS
+void SymDriveSearcher::helper_check_invariants(bool full_checks) {
+    // Check for duplicates
+    std::map<S2EExecutionState*, unsigned> counter1;
+    std::map<unsigned, unsigned> counter2;
+    std::map<SymDriveSearcherState*, unsigned> counter3;
+    foreach2(it1, m_states.begin(), m_states.end()) {
+        DECLARE_PLUGINSTATE_N(SymDriveSearcherState, it1_state, *it1);
+        ++counter1[*it1];
+        ++counter2[(*it1)->getID()];
+        ++counter3[it1_state];
+    }
+
+    foreach2(it1, counter1.begin(), counter1.end()) {
+        if (it1->second != 1) {
+            WARNING() << "State: " << it1->first->getID() << "\n";
+            assert (false && "State found multiple times (error 1).\n");
+        }
+    }
+
+    foreach2(it1, counter2.begin(), counter2.end()) {
+        if (it1->second != 1) {
+            WARNING() << "State: " << it1->first << "\n";
+            assert (false && "State found multiple times (error 2).\n");
+        }
+    }
+
+    foreach2(it1, counter3.begin(), counter3.end()) {
+        if (it1->second != 1) {
+            assert (false && "State found multiple times (error 3).\n");
+        }
+    }
+
+    // Check ordering
+    S2EExecutionState *es2 = NULL;
+    SymDriveSorter sorter;
+    sorter.p = this;
+    foreach2(it1, m_states.begin(), m_states.end()) {
+        S2EExecutionState *es1 = *it1;
+        if (es2 != NULL) {
+            assert (es2 != es1);
+            DECLARE_PLUGINSTATE_N(SymDriveSearcherState, es1_state, es1);
+            DECLARE_PLUGINSTATE_N(SymDriveSearcherState, es2_state, es2);
+            if (sorter (es2, es1) == false) {
+                WARNING()
+                    << "es1_state: " << hexval((unsigned long) es1_state)
+                    << ", priorityChange: " << es1_state->m_priorityChange
+                    << ", m_metric: " << es1_state->m_metric
+                    << ", m_metricValid: " << (es1_state->m_metricValid ? "true" : "false")
+                    << ", id: " << es1->getID()
+                    << "\n";
+                WARNING()
+                    << "es2_state: " << hexval((unsigned long) es2_state)
+                    << ", priorityChange: " << es2_state->m_priorityChange
+                    << ", m_metric: " << es2_state->m_metric
+                    << ", m_metricValid: " << (es2_state->m_metricValid ? "true" : "false")
+                    << ", id: " << es2->getID()
+                    << "\n";
+                assert (false);
+            }
+        }
+        es2 = *it1;
+    }
+
+    // Check that we can find everything
+    foreach2(it1, m_states.begin(), m_states.end()) {
+        S2EExecutionState *es = *it1;
+        if (m_states.find(es) == m_states.end()) {
+            assert(0 && "Unable to find state that's present");
+        }
+    }
+
+    //assert (m_states.size() <= m_states.size() + 1);
+}
+
+void SymDriveSearcher::helper_check_state_not_exists(S2EExecutionState *state) const {
+    assert(m_states.find (state) == m_states.end () && "primary m_states.find failure");
+
+    bool found = false;
+    foreach2(it1, m_states.begin(), m_states.end()) {
+        if ((*it1) == state) {
+            found = true;
+            break;
+        }
+    }
+
+    assert (!found && "secondary m_states.find failure -- this indicates improper set usage");
+}
+#else // ENABLE_INVARIANTS
+void SymDriveSearcher::helper_check_invariants(bool full_checks) {
+}
+
+void SymDriveSearcher::helper_check_state_not_exists(S2EExecutionState *state) const {
+}
+#endif
+
+void SymDriveSearcher::helper_dump_priorities(S2EExecutionState *state) const {
+    DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+
+    MESSAGE() << "==================================================" << "\n";
+    std::string stack = helper_driver_call_stack(plgState);
+    MESSAGE() << stack << "\n";
+    foreach2(it1, m_states.begin(), m_states.end()) {
+        S2EExecutionState *state = *it1;
+        DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+        MESSAGE()
+            << "[State " << state->getID() << "]"
+            << " pChg:" << plgState->m_priorityChange
+            << " met:" << plgState->m_metric
+            << "" << (plgState->m_metricValid ? "t" : "f")
+            << " sPth:" << plgState->m_successPath
+            << " cDep:" << plgState->m_driverCallStack
+            << " IP:" << hexval(state->getPc())
+            << " BB:"  << number_to_string(plgState->m_curTrackPerf[SymDriveSearcherState::BB])
+            << " I:"  << number_to_string(plgState->m_curTrackPerf[SymDriveSearcherState::INST])
+            << " PR:" << number_to_string(plgState->m_curTrackPerf[SymDriveSearcherState::PIO_Read])
+            << " PW:" << number_to_string(plgState->m_curTrackPerf[SymDriveSearcherState::PIO_Write])
+            << " MR:" << number_to_string(plgState->m_curTrackPerf[SymDriveSearcherState::MMIO_Read])
+            << " MW:" << number_to_string(plgState->m_curTrackPerf[SymDriveSearcherState::MMIO_Write])
+            << " DR:" << number_to_string(plgState->m_curTrackPerf[SymDriveSearcherState::DMA_Read])
+            << " DW:" << number_to_string(plgState->m_curTrackPerf[SymDriveSearcherState::DMA_Write])
+            << "\n";
+    }
+    MESSAGE() << "==================================================" << "\n";
+}
+
+bool SymDriveSearcher::helper_pointless_function(std::string fn) const {
+    static std::string pointless_functions[] = {
+        "inb",
+        "inb_local",
+        "inw",
+        "inw_local",
+        "inl",
+        "inl_local",
+        "outb",
+        "outb_local",
+        "outw",
+        "outw_local",
+        "outl",
+        "outl_local",
+        "writeb",
+        "writew",
+        "writel",
+        "readb",
+        "readw",
+        "readl",
+        ""
+    };
+
+    int j;
+    bool pointless = false;
+    for (j = 0;; j++) {
+        if (pointless_functions[j] == "") {
+            break;
+        }
+
+        if (fn == pointless_functions[j]) {
+            pointless = true;
+            break;
+        }
+    }
+
+    return pointless;
+}
+
+std::string SymDriveSearcher::helper_driver_call_stack(const SymDriveSearcherState *plgState) const {
+    std::string str_function;
+    if(plgState->m_functionCallStackFn.empty()) {
+        str_function = "Not in driver";
+    } else {
+        int i;
+        char temp[128];
+        for (i = 0; i < (int) plgState->m_functionCallStackFn.size(); i++) {
+            sprintf (temp, "%s:%d -> ",
+                     plgState->m_functionCallStackFn[i].c_str(),
+                     plgState->m_functionCallStackLine[i]);
+            str_function += temp;
+        }
+    }
+
+    return str_function;
+}
+
+void SymDriveSearcher::helper_ETraceInstr (S2EExecutionState *state, uint64_t pc, uint64_t delta, std::string fn) const {
+    // Using S2E trace infrastructure too
+    ExecutionTraceInstr e;
+    memset(&e, 0, sizeof(e));
+    e.state_id = state->getID();
+    e.pc = pc;
+    e.delta = delta;
+    strncpy (e.fn, fn.c_str(), 32);
+    m_tracer->writeData(state, &e, sizeof(e), TRACE_INSTR);
+}
+
+void SymDriveSearcher::helper_ETraceBB (S2EExecutionState *state, uint64_t pc, uint64_t delta, std::string fn) const {
+    ExecutionTraceBB e;
+    memset(&e, 0, sizeof(e));
+    e.state_id = state->getID();
+    e.pc = pc;
+    e.delta = delta;
+    strncpy (e.fn, fn.c_str(), 32);
+    m_tracer->writeData(state, &e, sizeof(e), TRACE_BB);
+}
+
+void SymDriveSearcher::helper_ETraceEvent(S2EExecutionState *state, int event) const {
+    ExecutionTraceEvent e;
+    memset(&e, 0, sizeof(e));
+    e.state_id = state->getID();
+    e.pc = state->getPc();
+    e.event = event;
+    m_tracer->writeData(state, &e, sizeof(e), TRACE_EVENT);
+}
+
+void SymDriveSearcher::helper_ETraceSuccess (S2EExecutionState *state, std::string fn, uint64_t success) const {
+    ExecutionTraceSuccessPath e;
+    e.state_id = state->getID();
+    e.pc = state->getPc();
+    strncpy (e.fn, fn.c_str(), 32);
+    e.success = success;
+    m_tracer->writeData(state, &e, sizeof(e), TRACE_SUCCESS);
+}
+
+void SymDriveSearcher::helper_dump_io_map (S2EExecutionState *state) const {
+    int counter = 1;
+    DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+    foreach2(it, plgState->m_ioMap.begin(), plgState->m_ioMap.end()) {
+        MESSAGE_S() << counter << ", tag: " << (*it).first << " --> " << (*it).second << "\n";
+        counter++;
+    }
+}
+
+std::string SymDriveSearcher::helper_dump_allperf (S2EExecutionState *state) const {
+    DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+    StateSet::iterator itAllStates;
+    std::string list = "";
+
+    // Print current state information:
+    SymDriveSearcherState::RECORDED_OPERATIONS op;
+    std::string name;
+    for (op = SymDriveSearcherState::BB; op < SymDriveSearcherState::TRACKPERF_COUNT; op++) {
+        switch(op) {
+            case SymDriveSearcherState::BB: name = "BB"; break;
+            case SymDriveSearcherState::INST: name = "INST"; break;
+            case SymDriveSearcherState::PIO_Read: name = "PIO_Read"; break;
+            case SymDriveSearcherState::PIO_Write: name = "PIO_Write"; break;
+            case SymDriveSearcherState::MMIO_Read: name = "MMIO_Read"; break;
+            case SymDriveSearcherState::MMIO_Write: name = "MMIO_Write"; break;
+            case SymDriveSearcherState::DMA_Read: name = "DMA_Read"; break;
+            case SymDriveSearcherState::DMA_Write: name = "DMA_Write"; break;
+            default: assert (0);
+        }
+
+        list += helper_dump_perf(state, plgState->m_prevTrackPerf[op], name);
+
+        // Print remaining states:
+        for (itAllStates = m_states.begin(); itAllStates != m_states.end(); itAllStates++) {
+            S2EExecutionState *tempState = dynamic_cast<S2EExecutionState*>(*itAllStates);
+            DECLARE_PLUGINSTATE_N(SymDriveSearcherState, tempPlgState, tempState);
+            list += helper_dump_perf(tempState, tempPlgState->m_prevTrackPerf[op], name);
+        }
+    }
+
+    return list;
+}
+
+
+std::string SymDriveSearcher::helper_dump_perf (S2EExecutionState *state,
+                                             std::vector<int> &array,
+                                             std::string name) const {
+    std::vector<int>::iterator it;
+    std::string list;
+    int count;
+
+    if (array.size() == 0) {
+        return "";
+    }
+
+    list = "State ";
+    list += number_to_string (state->getID());
+    list += " ";
+    list += name;
+    list += " ";
+
+    for (it = array.begin(), count = 0;
+         it != array.end();
+         it++, count++) {
+        list += number_to_string(*it);
+        if (count < array.size() - 1) {
+            list += ", ";
+        }
+    }
+
+    list += "\n";
+    return list;
+}
+
+std::string SymDriveSearcher::helper_dump_trackperf (S2EExecutionState *state,
+                                                  std::vector<int> &array) const {
+    std::vector<int>::iterator it;
+    std::string list;
+    int count;
+    list = "State ";
+    list += number_to_string (state->getID());
+    list += " ";
+
+    for (it = array.begin(), count = 0;
+         it != array.end();
+         it++, count++) {
+        std::string str = "ERROR";
+        switch (*it) {
+            case PAUSE_PP: str = "PAUSE_PP"; break;
+            case CONTINUE_PP: str = "CONTINUE_PP"; break;
+
+            case PAUSE_STUB: str = "PAUSE_STUB"; break;
+            case CONTINUE_STUB: str = "CONTINUE_STUB"; break;
+
+            case PAUSE_IRQ: str = "PAUSE_IRQ"; break;
+            case CONTINUE_IRQ: str = "CONTINUE_IRQ"; break;
+
+            case PAUSE_AUTO: str = "PAUSE_AUTO"; break;
+            case START_AUTO: str = "START_AUTO"; break;
+            case CONTINUE_AUTO: str = "CONTINUE_AUTO"; break;
+            case STOP_AUTO: str = "STOP_AUTO"; break;
+            case DISCARD_AUTO: str = "DISCARD_AUTO"; break;
+
+            case START_MANUAL: str = "START_MANUAL"; break;
+            case PAUSE_MANUAL: str = "PAUSE_MANUAL"; break;
+            case CONTINUE_MANUAL: str = "CONTINUE_MANUAL"; break;
+            case STOP_MANUAL: str = "STOP_MANUAL"; break;
+            case DISCARD_MANUAL: str = "DISCARD_MANUAL"; break;
+
+            default: assert (false);
+        }
+
+        list += str;
+        if (count < array.size() - 1) {
+            list += ", ";
+        }
+    }
+    return list;
+}
+
+bool SymDriveSearcher::helper_should_trackperf(S2EExecutionState *state,
+                                            uint64_t pc,
+                                            const ModuleDescriptor **curModule,
+                                            const ModuleDescriptor **md,
+                                            std::string *function) const {
+    DECLARE_PLUGINSTATE_CONST(SymDriveSearcherState, state);
+
+    int size = plgState->m_TrackPerf.size();
+    if (size == 0) {
+        return false;
+    }
+
+    int back1 = -1, back2 = -1;
+    if (size >= 1) {
+        back1 = plgState->m_TrackPerf[size - 1];
+    }
+    if (size >= 2) {
+        back2 = plgState->m_TrackPerf[size - 2];
+    }
+
+    bool condition1 = back1 == START_MANUAL;
+    //bool condition2 = back1 == START_AUTO &&
+    //    back2 != PAUSE_PP &&
+    //    back2 != PAUSE_STUB &&
+    //    back2 != PAUSE_IRQ;
+    bool condition2 = false;
+    bool condition3 = plgState->m_TrackperfFnCnt > 0;
+
+    // If someone put in an annotation, then start regardless.
+    if (condition1 || condition2 || condition3) {
+        if (pc != 0 && curModule != NULL && md != NULL && function != NULL) {
+            *curModule = m_moduleExecutionDetector->getModule(state, pc);
+            if (!(*curModule)) {
+                return false;
+            }
+
+            *md = m_moduleExecutionDetector->getCurrentDescriptor(state);
+            if (!(*md)) {
+                return false;
+            }
+
+            if ((*md)->PrimaryModule) {
+                // uint64_t pc = state->getTb()->pc;
+                // true if not in pre/post/stubwrapper, false otherwise.
+                *function = AddrIsValid(*md, pc);
+                if (*function != "") {
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+
+            // Not in primary module, e.g. test_framework
+            return false;
+        }
+
+        // Tracking enabled but no PC specified so just do it.
+        return true;
+    } else {
+        return false;
+    }
+}
+
+void SymDriveSearcher::helper_perf_store(S2EExecutionState *state, SymDriveSearcherState *plgState) {
+    for (int i = 0; i < SymDriveSearcherState::TRACKPERF_COUNT; i++) {
+        plgState->m_prevTrackPerf[i].push_back(plgState->m_curTrackPerf[i]);
+    }
+}
+
+void SymDriveSearcher::helper_perf_reset(S2EExecutionState *state, SymDriveSearcherState *plgState) {
+    // Reset counters
+    for (int i = 0; i < SymDriveSearcherState::TRACKPERF_COUNT; i++) {
+        plgState->m_curTrackPerf[i] = 0;
+    }
+}
+
+int SymDriveSearcher::helper_readCallId (S2EExecutionState *state, SymDriveSearcherState *plgState) {
+    int call_id = 0;
+    bool ok = true;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                         &call_id, 4);
+    if (!ok) {
+        WARNING_S() << "ERROR: symbolic argument was passed to SymDriveSearcher "
+                       " insert_symbolic opcode" << "\n";
+    }
+    assert (call_id != 0 && "call_id should be nonzero");
+    return call_id;
+}
+
+void SymDriveSearcher::helper_push_driver_call_stack(S2EExecutionState *state,
+                                                  SymDriveSearcherState *plgState,
+                                                  std::string fn, int line) {
+    plgState->m_functionCallStackFn.push_back(fn);
+    plgState->m_functionCallStackLine.push_back(line);
+    helper_push_pop_trackperf(state, plgState, START_FN);
+
+}
+
+void SymDriveSearcher::helper_pop_driver_call_stack(S2EExecutionState *state,
+                                                 SymDriveSearcherState *plgState,
+                                                 std::string fn, int line) {
+    // std::string last = plgState->m_functionCallStackFn.back();
+    // std::string stack = helper_driver_call_stack(plgState);
+
+    // pop
+    int i;
+    assert(plgState->m_functionCallStackFn.size() ==
+           plgState->m_functionCallStackLine.size());
+    for (i = plgState->m_functionCallStackFn.size() - 1; i >= 0; i--) {
+        if (plgState->m_functionCallStackFn[i] == fn) {
+            plgState->m_functionCallStackFn.erase(plgState->m_functionCallStackFn.begin() + i);
+            plgState->m_functionCallStackLine.erase(plgState->m_functionCallStackLine.begin() + i);
+            break;
+        }
+    }
+
+    helper_push_pop_trackperf(state, plgState, STOP_FN);
+}
+
+void SymDriveSearcher::helper_push_pop_trackperf(S2EExecutionState *state,
+                                              SymDriveSearcherState *plgState,
+                                              int event) {
+    // This all could be made more efficient but we're only talk about a small number
+    // of string comparisons on each function entry/exit.
+    int i, j;
+    int stack_size = plgState->m_functionCallStackFn.size();
+    
+    // Reset everything
+    plgState->m_TrackperfFnCnt = 0;
+
+    // Things to keep in mind:
+    // Interrupt handlers are called by SymDrive so measuring
+    //  them too is almost inevitably a bad idea.
+    // Interrupt handlers call other functions that we may
+    //  want to track, so in that case, we should track the
+    //  function of interest.
+    int irq_depth = 0;
+    for (j = 0; j < plgState->m_functionCallStackFn.size(); j++) {
+        std::string cur_fn = plgState->m_functionCallStackFn[j];
+        if (irq_depth == 0) {
+            for (i = 0; i < m_TrackperfFn.size(); i++) {
+                // This is irritating
+                if (m_TrackperfFnFlags[i] == TRACKPERF_IRQ_HANDLER &&
+                    m_TrackperfFn[i] == cur_fn) {
+                    irq_depth++;
+                    break;
+                }
+            }
+        }
+        else {
+            irq_depth++;
+        }
+        
+        // irq_depth now contains the depth of the current
+        // function below the IRQ handler, where 1 =
+        // the interrupt handler itself, 2 = an fn called
+        // by the IRQ handler, 3 = an fn called by an fn
+        // called by the IRQ handler, etc.
+
+        if (irq_depth == 0) {
+        } else if (irq_depth == 1) {
+            // This means we do no tracking as soon as we
+            // see an interrupt handler on the stack.
+            if (m_TrackperfIRQ == TRACKPERF_IRQ_NONE) {
+                plgState->m_TrackperfFnCnt = 0;
+                return;
+            }
+            // We may have tracked_fn --> irq_handler
+            // or irq_handler --> tracked_fn
+            else if (m_TrackperfIRQ == TRACKPERF_IRQ_ONLY_CALLED) {
+                if (plgState->m_TrackperfFnCnt == 0) {
+                    // In this case we have 
+                    // non-tracked --> IRQ handler
+                    // so proceed
+                } else if (plgState->m_TrackperfFnCnt > 0) {
+                    // In this case we have 
+                    // tracked --> IRQ handler
+                    // so disable statistics
+                    plgState->m_TrackperfFnCnt = 0;
+                    return;
+                } else {
+                    assert (false && "m_TrackperfFnCnt < 0?");
+                }
+                continue;
+            }
+            else if (m_TrackperfIRQ == TRACKPERF_IRQ_ALL) {
+                // proceed as we may track everything
+            } else {
+                assert (false && "m_TrackperfIRQ strange value");
+            }
+        } else if (irq_depth > 1) {
+            // should abort early as per previous if statement
+            assert (m_TrackperfIRQ == TRACKPERF_IRQ_ONLY_CALLED ||
+                    m_TrackperfIRQ == TRACKPERF_IRQ_ALL);
+        } else {
+            assert (false && "m_TrackperfIRQ < 0?");
+        }
+
+        // To track the interrupt handler
+        // you need to add it to the list via
+        // the s2e_trackperf_fn callout.
+
+        for (i = 0; i < m_TrackperfFn.size(); i++) {
+            if (m_TrackperfFnFlags[i] == TRACKPERF_IRQ_HANDLER) {
+                continue;
+            }
+
+            if (m_TrackperfFnFlags[i] == TRACKPERF_NONTRANSITIVE && j < stack_size - 1) {
+                continue;
+            }
+
+            std::string tracked = m_TrackperfFn[i];
+            assert (
+                (m_TrackperfFnFlags[i] == TRACKPERF_TRANSITIVE) ||
+                (m_TrackperfFnFlags[i] == TRACKPERF_NONTRANSITIVE && j == stack_size - 1)
+                    );
+            // Recursive or non-recursive, this part is the same.
+            if (cur_fn == tracked) {
+                plgState->m_TrackperfFnCnt++;
+                helper_ETraceEvent(state, event);
+            }
+        }
+    }
+
+    // MESSAGE_S() << "m_TrackperfFnCnt: " << plgState->m_TrackperfFnCnt << "\n";
+}
+
+// accessType:
+//  0 = Port
+//  1 = MMIO
+//  2 = DMA
+// address: port or MMIO address
+// size: in bytes
+// value: value read/written
+// isWrite:
+//  true = we're doing an I/O write
+//  false = we're doing an I/O read
+void SymDriveSearcher::onIOMemoryAccess(S2EExecutionState *state,
+                                        int accessType,
+                                        klee::ref<klee::Expr> address, // or port
+                                        klee::ref<klee::Expr> value,
+                                        int sizeInBytes, // size in bytes
+                                        bool isWrite)
+{
+    DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+
+    bool isAddrCste = isa<klee::ConstantExpr>(address);
+    bool isValCste = isa<klee::ConstantExpr>(value);
+
+    uint64_t i_pc = state->getPc();
+    uint64_t i_virt_address = isAddrCste ? cast<klee::ConstantExpr>(address)->getZExtValue(64) : 0xDEADBEEF;
+    uint64_t i_phys_address = 0xDEADBEEF;
+    uint64_t i_value = isValCste ? cast<klee::ConstantExpr>(value)->getZExtValue(64) : 0xDEADBEEF;
+    uint64_t i_sizeInBytes = sizeInBytes;
+
+    const char *str_accessType;
+    switch (accessType) {
+        case 0: // Port
+            str_accessType = "Port";
+            break;
+        case 1: // MMIO
+            str_accessType = "MMIO";
+            break;
+        case 2: // DMA
+            str_accessType = "DMA";
+            break;
+        default:
+            assert (false && "Specify 0 for port I/O, 1 for MMIO");
+    }
+
+    const char *str_isWrite = (isWrite ? "Write" : "Read");
+
+    char s_virt_address[256];
+    char s_phys_address[256];
+    if (!isAddrCste) {
+        sprintf (s_virt_address, "%s", "symbolic");
+        sprintf (s_phys_address, "%s", "symbolic");
+    } else {
+        if (accessType == 1 || accessType == 2) {
+            i_phys_address = state->getPhysicalAddress(i_virt_address);
+            sprintf (s_phys_address, "0x%lx", i_phys_address);
+        } else {
+            sprintf (s_phys_address, "portI/O");
+        }
+        sprintf (s_virt_address, "0x%lx", i_virt_address);
+    }
+
+    char s_value[256];
+    if (!isValCste) {
+        sprintf (s_value, "%s", "symbolic");
+    } else {
+        sprintf (s_value, "0x%lx", i_value);
+    }
+
+    assert (plgState->m_functionCallStackFn.size () == plgState->m_functionCallStackLine.size());
+    std::vector<std::string> str_designated_functions;
+    int i;
+    for (i = (int) plgState->m_functionCallStackFn.size() - 1; i >= 0; i--) {
+        std::string current = plgState->m_functionCallStackFn[i];
+        if (helper_pointless_function(current)) {
+            continue;
+        }
+
+        str_designated_functions.push_back(current);
+        if (str_designated_functions.size() >= TRACE_HW_OP_NUM_FN) {
+            break;
+        }
+    }
+
+    // Defined in TraceEntries.h
+    ExecutionTraceHWAccess e;
+
+    // Zero things out
+    memset(&e, 0, sizeof(ExecutionTraceHWAccess));
+
+    e.pc = i_pc;
+    for (i = 0; i < TRACE_HW_OP_NUM_FN; i++) {
+        std::string last;
+        if (i < (int) str_designated_functions.size()) {
+            last = str_designated_functions[i];
+        } else {
+            last = TRACE_HW_OP_NID;
+        }
+        // Fit name in buffer
+        strncpy (e.fn_names[i], last.c_str(), sizeof(e.fn_names[i]));
+        // Guarantee null-terminated
+        e.fn_names[i][sizeof(e.fn_names[i]) - 1] = 0;
+    }
+    e.op = (enum TRACE_HW_OP) accessType;
+    e.write = isWrite;
+    e.virt_address = i_virt_address;
+    e.phys_address = i_phys_address;
+    e.address_symbolic = !isAddrCste;
+    e.value = i_value;
+    e.value_symbolic = !isValCste;
+    e.size = i_sizeInBytes;
+    e.flags = 0;
+
+    assert (e.op == s2e::plugins::TRACE_HW_PORT || \
+            e.op == s2e::plugins::TRACE_HW_IOMEM || \
+            e.op == s2e::plugins::TRACE_HW_DMA);
+    assert (e.write == 0 || e.write == 1);
+
+    std::string access_type = str_accessType;
+    std::string read_write = str_isWrite;
+    std::string functions;
+    int num_fn = 0;
+    for (i = TRACE_HW_OP_NUM_FN - 1; i >= 0; i--) {
+        if (strcmp (e.fn_names[i], TRACE_HW_OP_NID) == 0) {
+            continue;
+        }
+
+        if (num_fn > 0) {
+            functions += "\t\t";
+        }
+        functions += e.fn_names[i];
+        if (i > 0) {
+            functions += " -> ";
+        }
+        functions += "\n";
+        num_fn++;
+    }
+
+    MESSAGE_S() << "IOMemoryTracer: " << "\n"
+                << "\tPC: " << hexval(e.pc) << "\n"
+                << "\tFunction: " << functions
+                << "\tAccess Type: " << access_type << "\n"
+                << "\tRead/Write: " << read_write << "\n"
+                << "\tVirtual Address: " << hexval(e.virt_address)
+                    << ", symbolic? " << e.address_symbolic << "\n"
+                << "\tPhysical Address: " << hexval(e.phys_address)
+                    << ", symbolic? " << e.address_symbolic << "\n"
+                << "\tValue: " << e.value
+                    << ", symbolic? " << e.value_symbolic << "\n"
+                << "\tSize: " << (int) e.size << "\n"
+                << "\tFlags: " << (int) e.flags << "\n"
+                << "\tState ID: " << state->getID() << "\n";
+
+    m_tracer->writeData(state, &e, sizeof(e), TRACE_HW_ACCESS);
+
+    // Track h/w operation counts for specific function:
+    if (helper_should_trackperf(state, 0)) {
+        // Record all symbolic I/O assuming it's our driver.
+        if (e.op == s2e::plugins::TRACE_HW_PORT) {
+            MESSAGE_S() << "Recording PIO operation.\n";
+            if (e.write == 0) {
+                plgState->m_curTrackPerf[SymDriveSearcherState::PIO_Read]++;
+            } else {
+                plgState->m_curTrackPerf[SymDriveSearcherState::PIO_Write]++;
+            }
+        } else if (e.op == s2e::plugins::TRACE_HW_IOMEM) {
+            MESSAGE_S() << "Recording MMIO operation.\n";
+            if (e.write == 0) {
+                plgState->m_curTrackPerf[SymDriveSearcherState::MMIO_Read]++;
+            } else {
+                plgState->m_curTrackPerf[SymDriveSearcherState::MMIO_Write]++;
+            }
+        } else if (e.op == s2e::plugins::TRACE_HW_DMA) {
+            MESSAGE_S() << "Recording DMA operation.\n";
+            if (e.write == 0) {
+                plgState->m_curTrackPerf[SymDriveSearcherState::DMA_Read]++;
+            } else {
+                assert (false && "DMA writes are not currently being recorded?");
+                plgState->m_curTrackPerf[SymDriveSearcherState::DMA_Write]++;
+            }
+        } else {
+            assert (false);
+        }
+    }
+}
+
+//Update the metrics
+void SymDriveSearcher::onTraceTbEnd(S2EExecutionState* state, uint64_t pc)
+{
+    //Increment the number of times the current tb is executed
+    const ModuleDescriptor *curModule = m_moduleExecutionDetector->getModule(state, pc);
+    DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+    if (!curModule) {
+        //WARNING() << "GDB screwing up onTraceTb" << "\n";
+        //WARNING() << "This is normally an assertion failure." << "\n";
+        m_states.erase(state);
+        plgState->m_metricValid = false;
+        m_states.insert(state);
+        return;
+    }
+
+    const ModuleDescriptor *md = m_moduleExecutionDetector->getCurrentDescriptor(state);
+    uint64_t tbVa = curModule->ToRelative(state->getTb()->pc);
+    if (plgState->m_metricValid == false) {
+        m_states.erase(state);
+        plgState->m_metricValid = true;
+        m_states.insert(state);
+    }
+
+    if (!md) {
+        m_states.erase(state);
+        helper_check_state_not_exists(state);
+        helper_check_invariants (true);
+
+        m_coveredTbs[*curModule][tbVa]++;
+        plgState->m_metric = m_coveredTbs[*curModule][tbVa];
+        plgState->m_metric *= state->queryCost < 1 ? 1 : state->queryCost;
+
+        m_states.insert(state);
+        helper_check_invariants (true);
+        return;
+    }
+
+    uint64_t newPc = md->ToRelative(state->getPc());
+
+    TbMap &tbm = m_coveredTbs[*md];
+    TbMap::iterator NewTbIt = tbm.find(newPc);
+    TbMap::iterator CurTbIt = tbm.find(tbVa);
+
+    bool NextTbIsNew = NewTbIt == tbm.end();
+    bool CurTbIsNew = CurTbIt == tbm.end();
+
+    helper_check_invariants(true);
+    m_states.erase(state);
+    helper_check_state_not_exists(state);
+    helper_check_invariants (true);
+
+    /**
+     * Update the frequency of the current and next
+     * translation blocks
+     */
+    if (CurTbIsNew) {
+      tbm[tbVa] = 1;
+    }else {
+      (*CurTbIt).second++;
+    }
+
+    if (NextTbIsNew && md) {
+      tbm[newPc] = 0;
+    }
+
+    if (NextTbIsNew) {
+      tbm[newPc] = 0;
+    }
+
+    plgState->m_metric = tbm[newPc];
+    plgState->m_metric *= state->queryCost < 1 ? 1 : state->queryCost;
+
+/*
+    MESSAGE() << "[State " << state->getID()
+                               << "] - " << md->Name << ", Metric for 0x" << hexval(newPc+md->NativeBase)
+                               << " = " << plgState->m_metric
+                               << ", priorityChange: " << plgState->m_priorityChange << "\n";
+*/
+
+    m_states.insert(state);
+    helper_check_invariants (true);
+}
+
+void SymDriveSearcher::onTraceTbStart(S2EExecutionState* state, uint64_t pc) {
+    const ModuleDescriptor *curModule = NULL, *md = NULL;
+    std::string function;
+    if (helper_should_trackperf(state, pc, &curModule, &md, &function) == false) {
+        return;
+    }
+
+    // Trace translation block
+    DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+    uint64_t delta = pc - md->LoadBase;
+    MESSAGE_S() << "ExecutingBB Mod: " << md->Name
+                << ", PC: " << hexval(pc)
+                << ", delta: " << hexval(delta)
+                << ", FN: " << function
+                << "\n";
+    plgState->m_curTrackPerf[SymDriveSearcherState::BB]++;
+
+    // Using S2E trace infrastructure too
+    helper_ETraceBB (state, pc, delta, function);
+    m_lastTbTraced = pc;
+}
+
+void SymDriveSearcher::onTraceInstruction(S2EExecutionState* state, uint64_t pc) {
+    const ModuleDescriptor *curModule = NULL, *md = NULL;
+    std::string function;
+    if (helper_should_trackperf(state, pc, &curModule, &md, &function) == false) {
+        return;
+    }
+
+    // Trace instruction execution
+    DECLARE_PLUGINSTATE(SymDriveSearcherState, state);
+    uint64_t delta = pc - md->LoadBase;
+    MESSAGE_S() << "ExecutingInst Mod: " << md->Name
+                << ", PC: " << hexval(pc)
+                << ", delta: " << hexval(delta)
+                << ", FN: " << function
+                << "\n";
+    plgState->m_curTrackPerf[SymDriveSearcherState::INST]++;
+
+    // Make sure instr/BB match up.
+    if (m_lastTbTraced != 0) {
+        assert (pc == m_lastTbTraced);
+        m_lastTbTraced = 0;
+    }
+
+    helper_ETraceInstr (state, pc, delta, function);
+}
+
+void SymDriveSearcher::onTimer()
+{
+    //Calling this is very expensive and should be done as rarely as possible.
+    // llvm::sys::TimeValue curTime = llvm::sys::TimeValue::now();
+    // m_currentTime = curTime.seconds();
+    m_currentTime++;
+}
+
+S2EExecutionState *SymDriveSearcher::selectStateFS(void) {
+    if (m_states.size() > 0) {
+        S2EExecutionState *es = dynamic_cast<S2EExecutionState*>(*m_states.begin());
+        return es;
+    } else {
+        assert (false);
+    }
+}
+
+S2EExecutionState *SymDriveSearcher::selectStateMode1(int64_t target_metric) {
+    S2EExecutionState *state = NULL;
+
+    if (target_metric == 0 || target_metric == 1) {
+        if (m_states.size() > 0) {
+            S2EExecutionState *es = dynamic_cast<S2EExecutionState*>(*m_states.begin());
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, es);
+            if (plgState->m_metricValid &&
+                plgState->m_metric < 2) {
+                state = es;
+            }
+        }
+    }
+
+    if (state != NULL) {
+        return state;
+    }
+
+    if (target_metric >= 0 && target_metric < 100) {
+        // Find ANY state we track with the target metric
+        foreach2(it, m_states.begin(), m_states.end()) {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, *it);
+            if (plgState->m_metricValid &&
+                plgState->m_metric == target_metric) {
+                state = *it;
+                break;
+            }
+        }
+    } else if (target_metric == -1) {
+        int64_t max_metric = 0;
+        // Find a state that has a really high metric
+        foreach2(it, m_states.begin(), m_states.end()) {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, *it);
+            if (plgState->m_metricValid &&
+                plgState->m_metric > max_metric) {
+                state = *it;
+                max_metric = plgState->m_metric;
+            }
+        }
+    } else if (target_metric == -2) {
+        // Find a random state.
+        int rnd = rand() % m_states.size();
+        int count = 0;
+        foreach2(it, m_states.begin(), m_states.end()) {
+            if (count == rnd) {
+                state = *it;
+                break;
+            }
+            count++;
+        }
+    } else {
+        assert (false);
+    }
+    return state;
+}
+
+S2EExecutionState *SymDriveSearcher::selectStateMode2a(void) {
+    assert (m_favorSuccessful == false);
+    std::string FunctionRare = "";
+
+    // Find any rare functions
+    foreach2(it, m_FunctionCounts.begin(), m_FunctionCounts.end()) {
+        if ((*it).second < 3) {
+            FunctionRare = (*it).first;
+            break;
+        }
+    }
+
+    if (FunctionRare != "") {
+        foreach2(it, m_states.begin(), m_states.end()) {
+            DECLARE_PLUGINSTATE(SymDriveSearcherState, *it);
+            foreach2(cur_fn_name,
+                     plgState->m_functionCallStackFn.begin(),
+                     plgState->m_functionCallStackFn.end()) {
+                if (*cur_fn_name == FunctionRare) {
+                    return *it;
+                }
+            }
+        }
+    }
+
+    return NULL;
+}
+
+S2EExecutionState *SymDriveSearcher::selectStateMode2b(void) {
+#if 0
+    S2EExecutionState *state = NULL;
+
+    assert (m_favorSuccessful == false);
+
+    // Added this because of our prioritization scheme:
+    // Make sure this code mirrors the onFork path deletion code
+    //int most_negative = 0;
+    int least_negative = -10; // Rather than INT_MIN should cover typical failure paths in drivers
+    //int64_t best_metric = 0x7FFFFFFF;
+    int64_t worst_success_metric = 0;
+
+    // Find functions that have poor coverage
+    std::string poorestCoverageFunc;
+    double ratio = 0;
+    double worst_coverage = 2.0;
+    foreach2(it, m_BlockCounts.begin(), m_BlockCounts.end()) {
+        ratio = (double) (*it).second.blocks_touched.size () /
+            (double) (*it).second.total_blocks;
+        if (ratio < worst_coverage) {
+            poorestCoverageFunc = (*it).first;
+            worst_coverage = ratio;
+        }
+    }
+
+    foreach2(it, m_states.begin(), m_states.end()) {
+        DECLARE_PLUGINSTATE(SymDriveSearcherState, *it);
+        int64_t plgStateMetric;
+        if (plgState->m_metricValid == false) {
+            plgStateMetric = 0;
+        } else {
+            plgStateMetric = plgState->m_metric / plgState->m_driverCallStack;
+        }
+
+        if (plgState->m_successPath <= -1 &&
+            plgState->m_successPath > least_negative &&
+            plgStateMetric < worst_success_metric) {
+            state = *it;
+            least_negative = plgState->m_successPath;
+        }
+
+        /*
+          if (backupState1 == NULL) {
+          foreach2(cur_fn_name,
+          plgState->m_functionCallStackFn.begin(),
+          plgState->m_functionCallStackFn.end()) {
+          if (*cur_fn_name == poorestCoverageFunc) {
+          MESSAGE() << "Poorest Coverage: "
+          << poorestCoverageFunc
+          << ", ratio"
+          << worst_coverage
+          << "\n";
+          backupState1 = *it;
+          break;
+          }
+          }
+          }
+        */
+
+        /*
+          if (plgState->m_successPath >= 1 &&
+          plgStateMetric < 1000 &&
+          backupState2 == NULL) {
+          // Find a path that has some
+          // reasonable properties.
+          backupState2 = *it;
+          }
+        */
+    }
+
+    return state;
+#endif
+    return NULL;
+}
+
+// find a state with a target fn on the call stack (m_PrimaryFn)
+S2EExecutionState *SymDriveSearcher::selectStateMode3(void) {
+    S2EExecutionState *state = NULL;
+    int best_primary_fn_count = 0;
+
+    foreach2(it, m_states.begin(), m_states.end()) {
+        DECLARE_PLUGINSTATE(SymDriveSearcherState, *it);
+
+        int matched_count = 0;
+        foreach2(cur_fn_name,
+                 plgState->m_functionCallStackFn.begin(),
+                 plgState->m_functionCallStackFn.end()) {
+            foreach2(primary_fn_name,
+                     m_PrimaryFn.begin(),
+                     m_PrimaryFn.end()) {
+                if (*cur_fn_name == *primary_fn_name) {
+                    matched_count++;
+                }
+            }
+
+            if (matched_count > best_primary_fn_count) {
+                state = *it;
+                best_primary_fn_count = matched_count;
+            }
+        }
+    }
+
+    return state;
+}
+
+S2EExecutionState *SymDriveSearcher::selectStateMode4(bool greatest) {
+    S2EExecutionState *state = NULL;
+    int longest_success = 0;
+
+    foreach2(it, m_states.begin(), m_states.end()) {
+        DECLARE_PLUGINSTATE(SymDriveSearcherState, *it);
+        if (greatest) {
+            // Find state with longest success path
+            if (plgState->m_successPath > longest_success) {
+                longest_success = plgState->m_successPath;
+                state = *it;
+            }
+        } else {
+            // Find state with shortest success path
+            if (plgState->m_successPath < longest_success) {
+                longest_success = plgState->m_successPath;
+                state = *it;
+            }
+        }
+    }
+
+    return state;
+}
+
+S2EExecutionState *SymDriveSearcher::selectStateMode5(bool greatest) {
+    S2EExecutionState *state = NULL;
+    int greatest_call_depth = 0;
+
+    foreach2(it, m_states.begin(), m_states.end()) {
+        DECLARE_PLUGINSTATE(SymDriveSearcherState, *it);
+        if (greatest) {
+            // Find state with deepest call stack.
+            if (plgState->m_driverCallStack > greatest_call_depth) {
+                greatest_call_depth = plgState->m_driverCallStack;
+                state = *it;
+            }
+        } else {
+            // Find state with shallowest call stack.
+            if (plgState->m_driverCallStack < greatest_call_depth) {
+                greatest_call_depth = plgState->m_driverCallStack;
+                state = *it;
+            }
+        }
+    }
+
+    return state;
+}
+
+klee::ExecutionState& SymDriveSearcher::selectState()
+{
+    S2EExecutionState *state = NULL;
+
+    if (m_favorSuccessful == true) {
+        // Re-execute current state until g_time_budget_fs (favor successful)
+        if ((m_currentTime - m_lastStartTime) < g_time_budget_fs && m_lastState != NULL) {
+            state = m_lastState;
+        }
+
+        if (state == NULL) {
+            state = selectStateFS();
+        }
+    } else {
+        // Re-execute current state until g_time_budget_mc (max coverage)
+        if ((m_currentTime - m_lastStartTime) < g_time_budget_mc && m_lastState != NULL) {
+            state = m_lastState;
+        }
+
+        if (state == NULL) {
+            // We need to pick the state that's most likely
+            // to uncover new code.  Ideas?
+            state = selectStateMode1(0); // metric = 1
+        }
+
+        if (state == NULL) {
+            if (m_selectionMode == 1) {
+            } else if (m_selectionMode == 2) {
+                state = selectStateMode1(-1); // metric = very high
+            } else if (m_selectionMode == 3) {
+                state = selectStateMode2a();
+            } else if (m_selectionMode == 4) {
+                state = selectStateMode3();
+            } else if (m_selectionMode == 5) {
+                state = selectStateMode4(true);
+            } else if (m_selectionMode == 6) {
+                state = selectStateMode4(false);
+            } else if (m_selectionMode == 7) {
+                state = selectStateMode5(true);
+            } else if (m_selectionMode == 8) {
+                state = selectStateMode5(false);
+            } else {
+                assert (false);
+            }
+
+            m_selectionMode++;
+            if (m_selectionMode > 8) {
+                m_selectionMode = 1;
+            }
+        }
+    }
+
+    if (state == NULL) {
+        state = selectStateMode1(-2); // random state
+        assert (state != NULL);
+    }
+
+    // If this is true, we're selecting a new state:
+    if (state != m_lastState) {
+        helper_dump_priorities(state);
+
+        m_lastState = state;
+        m_lastStartTime = m_currentTime;
+    }
+
+    assert ((state->isActive() == false) ||
+            (state->isActive() == true && state == m_lastState));
+
+    return *state;
+}
+
+bool SymDriveSearcher::updatePc(S2EExecutionState *es)
+{
+    const ModuleDescriptor* md = m_moduleExecutionDetector->getCurrentDescriptor(es);
+    DECLARE_PLUGINSTATE(SymDriveSearcherState, es);
+
+    if (!md) {
+        MESSAGE() << "SymDriveSearcher: state in unknown location" << "\n";
+        plgState->m_metricValid = false;
+        m_states.insert(es);
+        return false;
+    }
+
+    //Retrieve the next program counter of the state
+    uint64_t absNextPc = computeTargetPc(es); // XXX: fix me
+
+    if (!absNextPc) {
+        MESSAGE() << "SymDriveTBSearcher: could not determine next pc" << "\n";
+        //Could not determine next pc
+        plgState->m_metricValid = false;
+        m_states.insert(es);
+        return false;
+    }
+
+    //If not covered, add the forked state to the wait list
+    plgState->m_metricValid = true;
+    plgState->m_metric = m_coveredTbs[*md][md->ToRelative(absNextPc)];
+    m_states.insert(es);
+    helper_check_invariants (false); // Invariant may not hold as we're in the middle of an update.
+
+    MESSAGE() << "[StateX " << es->getID()
+              << "] - " << md->Name << ", Metric for 0x" << hexval(es->getPc())
+              << " = " << plgState->m_metric
+              << ", priorityChange: " << plgState->m_priorityChange << "\n";
+
+    return true;
+}
+
+void SymDriveSearcher::update(klee::ExecutionState *state,
+                              const std::set<klee::ExecutionState*> &addedStates,
+                              const std::set<klee::ExecutionState*> &removedStates)
+{
+    // MESSAGE() << "update! " << addedStates.size() << ", " << removedStates.size() << "\n";
+
+    foreach2(it, addedStates.begin(), addedStates.end()) { // Swapped order
+        S2EExecutionState *es = dynamic_cast<S2EExecutionState*>(*it);
+        updatePc(es);
+    }
+
+    foreach2(it, removedStates.begin(), removedStates.end()) {
+        S2EExecutionState *es = dynamic_cast<S2EExecutionState*>(*it);
+        // Invariant may not hold as we're in the middle of an update.
+        helper_check_invariants (false);
+
+        if (m_dumpiomap_enabled) {
+            // Print out the names + locations of I/O read operations.
+            helper_dump_io_map(es);
+        }
+
+        m_states.erase(es);
+        if (es == m_lastState) {
+            m_lastState = NULL;
+        }
+        helper_check_state_not_exists(es);
+        helper_check_invariants (false);
+    }
+
+    helper_check_invariants (false);
+}
+
+bool SymDriveSearcher::empty()
+{
+    return m_states.empty();
+}
+
+bool SymDriveSearcher::establishIOMap(std::string tag) const {
+    DECLARE_PLUGINSTATE(SymDriveSearcherState, g_s2e_state);
+    plgState->m_ioMap[tag] = helper_driver_call_stack(plgState);
+    return true;
+}
+
+extern "C" {
+
+static bool io_map_callback (std::string tag, void *opaque) {
+    SymDriveSearcher *searcher = static_cast<SymDriveSearcher *>(opaque);
+    return searcher->establishIOMap(tag);
+}
+
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+SymDriveSearcherState::SymDriveSearcherState()
+{
+
+}
+
+SymDriveSearcherState::SymDriveSearcherState(S2EExecutionState *s, Plugin *p)
+{
+    m_metric = 0;
+    m_metricValid = true;
+    m_priorityChange = 0;
+    m_successPath = 0;
+    m_plugin = static_cast<SymDriveSearcher*>(p);
+
+    m_driverCallStack = 0;
+    m_TrackperfFnCnt = 0;
+
+    int i;
+    for (i = 0; i < SymDriveSearcherState::TRACKPERF_COUNT; i++) {
+        m_curTrackPerf[i] = 0;
+    }
+}
+
+SymDriveSearcherState::~SymDriveSearcherState()
+{
+}
+
+PluginState *SymDriveSearcherState::clone() const
+{
+    size_t i;
+    SymDriveSearcherState *retval = new SymDriveSearcherState(*this);
+    assert (this->m_metric == retval->m_metric);
+    assert (this->m_metricValid == retval->m_metricValid);
+    assert (this->m_priorityChange == retval->m_priorityChange);
+    assert (this->m_successPath == retval->m_successPath);
+    assert (this->m_driverCallStack == retval->m_driverCallStack);
+
+    assert (this->m_TrackPerf.size() == retval->m_TrackPerf.size());
+
+    for (i = 0; i < TRACKPERF_COUNT; i++) {
+        assert (this->m_curTrackPerf[i] == retval->m_curTrackPerf[i]);
+    }
+
+    assert (this->m_loopStates.size() == retval->m_loopStates.size());
+    assert (this->m_functionCallStackFn.size() == retval->m_functionCallStackFn.size());
+    assert (this->m_functionCallStackLine.size() == retval->m_functionCallStackLine.size());
+    for (i = 0; i < this->m_loopStates.size(); i++) {
+        assert (this->m_loopStates[i] == retval->m_loopStates[i]);
+    }
+
+    // General sanity
+    assert (this->m_functionCallStackFn.size() == this->m_functionCallStackLine.size());
+    return retval;
+}
+
+PluginState *SymDriveSearcherState::factory(Plugin *p, S2EExecutionState *s)
+{
+    SymDriveSearcherState *ret = new SymDriveSearcherState(s, p);
+    return ret;
+}
+
+//////////////////////////////
+// Sorting
+//////////////////////////////
+SymDriveSorter::SymDriveSorter() {
+    p = NULL;
+}
+
+bool SymDriveSorter::operator()(const S2EExecutionState *s1, const S2EExecutionState *s2) const {
+    // return true if s1 is higher priority
+    // return false if s2 is higher priority
+
+    const SymDriveSearcherState *p1 = static_cast<SymDriveSearcherState*>
+        (p->getPluginState(const_cast<S2EExecutionState*>(s1), &SymDriveSearcherState::factory));
+    const SymDriveSearcherState *p2 = static_cast<SymDriveSearcherState*>
+        (p->getPluginState(const_cast<S2EExecutionState*>(s2), &SymDriveSearcherState::factory));
+
+    if (s1 == s2) {
+        assert (p1 == p2);
+    }
+    if (s1 != s2) {
+        assert (p1 != p2);
+    }
+    if (p1 == p2) {
+        assert (s1 == s2);
+    }
+    if (p1 != p2) {
+        assert (s1 != s2);
+    }
+
+    if (p->m_favorSuccessful == true) {
+        // ignore metric
+        if (p1->m_priorityChange > p2->m_priorityChange) {
+            return true;
+        } else if (p1->m_priorityChange == p2->m_priorityChange) {
+            return s1->getID() < s2->getID();
+        } else {
+            return false;
+        }
+    } else {
+        // metric is more important now
+        if (p1->m_metricValid == true && p2->m_metricValid == false) {
+            return true;
+        } else if (p1->m_metricValid == false && p2->m_metricValid == true) {
+            return false;
+        } else {
+            if (p1->m_metric < p2->m_metric) {
+                return true;
+            } else if (p1->m_metric == p2->m_metric) {
+                return s1->getID() < s2->getID();
+            } else {
+                return false;
+            }
+        }
+    }
+}
+
+} // namespace plugins
+} // namespace s2e
diff --git a/qemu/s2e/Plugins/SymDrive/SymDriveSearcher.h b/qemu/s2e/Plugins/SymDrive/SymDriveSearcher.h
new file mode 100644
index 0000000..1845c2c
--- /dev/null
+++ b/qemu/s2e/Plugins/SymDrive/SymDriveSearcher.h
@@ -0,0 +1,409 @@
+/*
+ * S2E Selective Symbolic Execution Framework
+ *
+ * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Dependable Systems Laboratory, EPFL nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE DEPENDABLE SYSTEMS LABORATORY, EPFL BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Currently maintained by:
+ *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
+ *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
+ *
+ * All contributors are listed in S2E-AUTHORS file.
+ *
+ */
+
+#ifndef S2E_PLUGINS_SYMDRIVESEARCHER_H
+#define S2E_PLUGINS_SYMDRIVESEARCHER_H
+
+#include <s2e/Plugin.h>
+#include <s2e/Plugins/CorePlugin.h>
+#include <s2e/Plugins/ModuleExecutionDetector.h>
+#include <s2e/S2EExecutionState.h>
+
+#include "../ExecutionTracers/ExecutionTracer.h" // tracing
+#include "../SymbolicHardware.h" // tracing
+#include "../RawMonitor.h" // tracing
+
+#include "MCoverageBasics.h" // basic blocks
+
+#include <klee/Searcher.h>
+
+#include <vector>
+
+namespace s2e {
+
+class S2EExecutor;
+
+namespace plugins {
+
+template <typename T> std::string number_to_string(T number)
+{
+    return dynamic_cast<std::stringstream *> (&(std::stringstream() << number))->str();
+}
+
+class SymDriveSearcher;
+class SymDriveSearcherState;
+
+struct SymDriveModuleInfo {
+    SymDriveModuleInfo() {
+        m_moduleName = "";
+        m_moduleDir = "";
+        m_numGaps = 0;
+        m_bytesInGaps = 0;
+        m_bytesTotal = 0;
+    }
+    std::string m_moduleName;
+    std::string m_moduleDir;
+    s2etools::BasicBlocks m_allBbs;
+    s2etools::Functions m_functions;
+    s2etools::BBToFunction m_AddrToFunction;
+    std::map<uint64_t, bool> m_AddrValid;
+    int m_numGaps;
+    int m_bytesInGaps;
+    int m_bytesTotal;
+};
+
+class SymDriveSorter {
+    friend class s2e::plugins::SymDriveSearcher;
+  private:
+    SymDriveSearcher *p;
+  public:
+    SymDriveSorter();
+    bool operator()(const S2EExecutionState *s1, const S2EExecutionState *s2) const;
+};
+
+typedef std::set<S2EExecutionState*, SymDriveSorter> StateSet;
+
+class SymDriveSearcherState: public PluginState
+{
+    friend class s2e::plugins::SymDriveSorter;
+  public:
+    enum RECORDED_OPERATIONS {
+        BB,
+        INST,
+        PIO_Read,
+        PIO_Write,
+        MMIO_Read,
+        MMIO_Write,
+        DMA_Read,
+        DMA_Write,
+        TRACKPERF_COUNT
+    };
+
+  private:
+    int64_t m_metric;
+    bool m_metricValid;
+    int m_priorityChange;
+    int m_successPath;
+    SymDriveSearcher *m_plugin;
+    std::vector<unsigned int> m_loopStates;
+    int m_driverCallStack;
+    std::map<std::string, std::string> m_ioMap;
+
+    std::vector<std::string> m_functionCallStackFn;
+    std::vector<int> m_functionCallStackLine;
+
+    //
+    // Performance tracking
+    //
+    std::vector<int> m_TrackPerf;
+    int m_TrackperfFnCnt; // > 0 if we've entered an interesting fn.
+
+    int m_curTrackPerf[TRACKPERF_COUNT];
+    std::vector<int> m_prevTrackPerf[TRACKPERF_COUNT];
+
+  public:
+    SymDriveSearcherState();
+    SymDriveSearcherState(S2EExecutionState *s, Plugin *p);
+    virtual ~SymDriveSearcherState();
+    virtual PluginState *clone() const;
+    static PluginState *factory(Plugin *p, S2EExecutionState *s);
+
+    friend class SymDriveSearcher;
+};
+
+class SymDriveSearcher : public Plugin, public klee::Searcher
+{
+    S2E_PLUGIN
+    friend class s2e::plugins::SymDriveSorter;
+  public:
+    //Maps a translation block address to the number of times it was executed
+    typedef std::map<uint64_t, uint64_t> TbMap;
+    typedef std::map<ModuleDescriptor, TbMap, ModuleDescriptor::ModuleByName > TbsByModule;
+
+  SymDriveSearcher(S2E* s2e): Plugin(s2e) {}
+    void initialize();
+
+  private:
+    // basic blocks
+    void initializeBB (void);
+    void initSection(const std::string &cfgKey, const std::string &svcId);
+    void ReadBBList(SymDriveModuleInfo &module);
+    void BBValidate(const SymDriveModuleInfo &module) const;
+    std::string AddrToFunction(const ModuleDescriptor *md, uint64_t address) const;
+    std::string AddrIsValid (const ModuleDescriptor *md, uint64_t address) const;
+    
+    void initializeSearcher();
+    uint64_t computeTargetPc(S2EExecutionState *s);
+    void onModuleTranslateBlockEnd(
+        ExecutionSignal *signal,
+        S2EExecutionState* state,
+        const ModuleDescriptor &,
+        TranslationBlock *tb,
+        uint64_t endPc,
+        bool staticTarget,
+        uint64_t targetPc);
+    void onModuleTranslateBlockStart(
+        ExecutionSignal *signal,
+        S2EExecutionState* state,
+        const ModuleDescriptor &,
+        TranslationBlock *tb,
+        uint64_t endPc);
+    void onTranslateInstructionStart(
+        ExecutionSignal *signal,
+        S2EExecutionState* state,
+        TranslationBlock *tb,
+        uint64_t pc);
+    void onFork(S2EExecutionState *originalState,
+                const std::vector<S2EExecutionState*>& newStates,
+                const std::vector<klee::ref<klee::Expr> >& newConditions);
+    void onCustomInstruction   (S2EExecutionState *state, uint64_t opcode);
+
+    // Opcodes
+    // If you update this, be sure to update root_annot_dri.ml
+    // and s2e.h
+#define SYMDRIVE_OPCODE_ARGS S2EExecutionState *state, SymDriveSearcherState* plgState, int line
+    void s2e_prioritize           (SYMDRIVE_OPCODE_ARGS);
+    void s2e_deprioritize         (SYMDRIVE_OPCODE_ARGS);
+    void s2e_loop_before          (SYMDRIVE_OPCODE_ARGS);
+    void s2e_loop_body            (SYMDRIVE_OPCODE_ARGS);
+    void s2e_loop_after           (SYMDRIVE_OPCODE_ARGS);
+    void s2e_concretize_kill      (SYMDRIVE_OPCODE_ARGS);
+    void s2e_concretize_all       (SYMDRIVE_OPCODE_ARGS);
+    void s2e_kill_all_others      (SYMDRIVE_OPCODE_ARGS);
+    void s2e_driver_call_stack    (SYMDRIVE_OPCODE_ARGS);
+    void s2e_favor_successful     (SYMDRIVE_OPCODE_ARGS);
+    // hole
+    void s2e_reset_priorities     (SYMDRIVE_OPCODE_ARGS);
+    // hole
+    void s2e_enable_tracing       (SYMDRIVE_OPCODE_ARGS);
+    void s2e_disable_tracing      (SYMDRIVE_OPCODE_ARGS);
+    void s2e_enterexit_function   (SYMDRIVE_OPCODE_ARGS, bool enter); // helper
+    void s2e_enter_function       (SYMDRIVE_OPCODE_ARGS);
+    void s2e_exit_function        (SYMDRIVE_OPCODE_ARGS);
+    void s2e_is_symbolic_symdrive (SYMDRIVE_OPCODE_ARGS);
+    void s2e_success_path         (SYMDRIVE_OPCODE_ARGS);
+    void s2e_enter_block          (SYMDRIVE_OPCODE_ARGS);
+    void s2e_primary_fn           (SYMDRIVE_OPCODE_ARGS);
+    void s2e_enable_trackperf     (SYMDRIVE_OPCODE_ARGS);
+    void s2e_disable_trackperf    (SYMDRIVE_OPCODE_ARGS);
+    void s2e_trackperf_fn         (SYMDRIVE_OPCODE_ARGS);
+    void s2e_io_region            (SYMDRIVE_OPCODE_ARGS);
+#undef SYMDRIVE_OPCODE_ARGS
+
+    // Helpers
+    void helper_check_invariants (bool full_checks);
+    void helper_check_state_not_exists (S2EExecutionState *state) const;
+    void helper_stop_rescheduling (void) const;
+    void helper_dump_priorities (S2EExecutionState *state) const;
+    bool helper_pointless_function(std::string fn) const;
+    std::string helper_driver_call_stack(const SymDriveSearcherState *plgState) const;
+    void helper_ETraceInstr (S2EExecutionState *state, uint64_t pc, uint64_t delta, std::string fn) const;
+    void helper_ETraceBB (S2EExecutionState *state, uint64_t pc, uint64_t delta, std::string fn) const;
+    void helper_ETraceEvent (S2EExecutionState *state, int event) const;
+    void helper_ETraceSuccess (S2EExecutionState *state, std::string fn, uint64_t success) const;
+    void helper_dump_io_map (S2EExecutionState *state) const;
+    std::string helper_dump_allperf (S2EExecutionState *state) const;
+    std::string helper_dump_perf (S2EExecutionState *state,
+                               std::vector<int> &array,
+                               std::string name) const;
+    std::string helper_dump_trackperf (S2EExecutionState *state,
+                                    std::vector<int> &array) const;
+    bool helper_should_trackperf(S2EExecutionState *state,
+                              uint64_t pc,
+                              const ModuleDescriptor **curModule = NULL,
+                              const ModuleDescriptor **md = NULL,
+                              std::string *function = NULL) const;
+    void helper_perf_store(S2EExecutionState *state,
+                        SymDriveSearcherState *plgState);
+    void helper_perf_reset(S2EExecutionState *state,
+                        SymDriveSearcherState *plgState);
+    int helper_readCallId(S2EExecutionState *state,
+                       SymDriveSearcherState *plgState);
+    void helper_push_driver_call_stack (S2EExecutionState *state,
+                                     SymDriveSearcherState *plgState,
+                                     std::string fn,
+                                     int line);
+    void helper_pop_driver_call_stack  (S2EExecutionState *state,
+                                     SymDriveSearcherState *plgState,
+                                     std::string fn,
+                                     int line);
+    void helper_push_pop_trackperf (S2EExecutionState *state,
+                                 SymDriveSearcherState *plgState,
+                                 int event);
+
+    // Tracing
+    void onIOMemoryAccess(S2EExecutionState *state,
+                          int accessType,
+                          klee::ref<klee::Expr> address,
+                          klee::ref<klee::Expr> value,
+                          int sizeInBytes,
+                          bool isWrite);
+
+    void onTraceTbEnd(S2EExecutionState* state, uint64_t pc);
+    void onTraceTbStart(S2EExecutionState* state, uint64_t pc);
+    void onTraceInstruction(S2EExecutionState* state, uint64_t pc);
+    void onTimer(void);
+
+    // State selection
+    S2EExecutionState *selectStateFS(void);
+    S2EExecutionState *selectStateMode1(int64_t target_metric);
+    S2EExecutionState *selectStateMode2a(void);
+    S2EExecutionState *selectStateMode2b(void);
+    S2EExecutionState *selectStateMode3(void);
+    S2EExecutionState *selectStateMode4(bool greatest);
+    S2EExecutionState *selectStateMode5(bool greatest);
+  public:
+    virtual klee::ExecutionState& selectState();
+
+  private:
+    // Inherited member functions
+    bool updatePc(S2EExecutionState *es);
+  public:
+    virtual void update(klee::ExecutionState *current,
+                        const std::set<klee::ExecutionState*> &addedStates,
+                        const std::set<klee::ExecutionState*> &removedStates);
+
+    virtual bool empty();
+
+    // Sets up a mapping between I/O tag and driver call stack.
+    bool establishIOMap (std::string tag) const;
+    
+    ////////////////////////////////////////////////////////
+    // Member variables
+    ////////////////////////////////////////////////////////
+  private:
+    static const int PRIORITY_FIDDLE = 1000;
+    static const int PRIORITY_YIELD = 50000;
+    static const int PRIORITY_EXTREME = 2000000000;
+
+    // Module execution
+    ModuleExecutionDetector *m_moduleExecutionDetector;
+    bool m_searcherInited;
+    TbsByModule m_coveredTbs;
+
+    // State management
+    SymDriveSorter m_sorter;
+    StateSet m_states;
+    typedef std::map<int, int> IntMap;
+    // static const int MAX_PENALTY = 128;
+    static const int MAX_PENALTY = 10;
+    IntMap m_currentPenalty;
+    IntMap m_loopCount;
+    std::map<std::string, int> m_FunctionCounts;
+    typedef struct {
+        std::string function;
+        int total_blocks;
+        std::map<int, bool> blocks_touched;
+    } CBlocks;
+    std::map<std::string, CBlocks> m_BlockCounts;
+    std::vector<std::string> m_PrimaryFn;
+
+    // Scheduling
+    bool m_favorSuccessful;
+    uint64_t m_currentTime;
+    uint64_t m_lastStartTime;
+    S2EExecutionState *m_lastState;
+
+    // Selection mode
+    int m_selectionMode;
+
+    // Tracing / Performance analysis
+    int m_dumpiomap_enabled;
+    sigc::connection m_memoryMonitor;
+    ExecutionTracer *m_tracer;
+    RawMonitor *m_mon;
+    
+    TranslationBlock *m_tb; // instruction / TB tracing
+    sigc::connection m_tbConnection;
+    uint64_t m_lastTbTraced;
+    std::vector<std::string> m_TrackperfFn;
+    std::vector<int> m_TrackperfFnFlags;
+    int m_TrackperfIRQ;
+        
+    // Symbolic hardware
+    SymbolicHardware *m_hw;
+
+    // Trackperf:
+    // Update s2e.h if this changes
+    // Update MTbTrace if this changes
+    // Update helper_dump_trackperf if this changes
+    const static int PAUSE_PP = 11;
+    const static int CONTINUE_PP = 12; // Return to previous state
+
+    const static int PAUSE_STUB = 21;
+    const static int CONTINUE_STUB = 22;
+
+    const static int PAUSE_IRQ = 31;
+    const static int CONTINUE_IRQ = 32;
+
+    const static int START_AUTO = 40;
+    const static int PAUSE_AUTO = 41;
+    const static int CONTINUE_AUTO = 42;
+    const static int STOP_AUTO = 43;
+    const static int DISCARD_AUTO = 44;
+
+    const static int START_MANUAL = 50;
+    const static int PAUSE_MANUAL = 51;
+    const static int CONTINUE_MANUAL = 52;
+    const static int STOP_MANUAL = 53;
+    const static int DISCARD_MANUAL = 54;
+
+    // Used only by helper_push_driver_call_stack / pop_driver_call_stack
+    // Used only for tracing events.
+    const static int START_FN = 60;
+    const static int STOP_FN = 61;
+
+    const static int TRACKPERF_IRQ_NONE = 1000; // Handler + called functions not tracked
+    const static int TRACKPERF_IRQ_ONLY_CALLED = 1001; // Handler not tracked, called functions maybe
+    const static int TRACKPERF_IRQ_ALL = 1002; // Handler + called functions tracked
+
+    // Used for trackperf_fn / push_pop_trackperf
+    const static int TRACKPERF_NONTRANSITIVE = 0;
+    const static int TRACKPERF_TRANSITIVE = 1;
+    const static int TRACKPERF_IRQ_HANDLER = 1000; // See root_annot_dri.ml mk_register_irq_stmts
+
+    //////////////////////// Trackperf
+
+    // Basic blocks:
+    std::vector<SymDriveModuleInfo> m_Modules;
+
+    friend class SymDriveSearcherState;
+};
+
+} // namespace plugins
+} // namespace s2e
+
+#endif
diff --git a/qemu/s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.cpp b/qemu/s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.cpp
new file mode 100644
index 0000000..e287196
--- /dev/null
+++ b/qemu/s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.cpp
@@ -0,0 +1,193 @@
+/*
+ * S2E Selective Symbolic Execution Framework
+ *
+ * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Dependable Systems Laboratory, EPFL nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE DEPENDABLE SYSTEMS LABORATORY, EPFL BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Currently maintained by:
+ *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
+ *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
+ *
+ * All contributors are listed in S2E-AUTHORS file.
+ *
+ */
+
+extern "C" {
+#include "config.h"
+//#include "cpu.h"
+//#include "exec-all.h"
+#include "qemu-common.h"
+}
+
+
+#include "SymDriveTranslationBlockTracer.h"
+#include <s2e/S2E.h>
+#include <s2e/ConfigFile.h>
+#include <s2e/Utils.h>
+
+#include <iostream>
+
+namespace s2e {
+namespace plugins {
+
+S2E_DEFINE_PLUGIN(SymDriveTranslationBlockTracer, "Tracer for executed translation blocks", "SymDriveTranslationBlockTracer", "ExecutionTracer",
+                  "ModuleExecutionDetector");
+
+void SymDriveTranslationBlockTracer::initialize()
+{
+    m_tracer = (ExecutionTracer *)s2e()->getPlugin("ExecutionTracer");
+    m_detector = (ModuleExecutionDetector*)s2e()->getPlugin("ModuleExecutionDetector");
+
+    m_detector->onModuleTranslateBlockStart.connect(
+            sigc::mem_fun(*this, &SymDriveTranslationBlockTracer::onModuleTranslateBlockStart)
+    );
+
+    m_detector->onModuleTranslateBlockEnd.connect(
+            sigc::mem_fun(*this, &SymDriveTranslationBlockTracer::onModuleTranslateBlockEnd)
+    );
+
+#if 0
+    //XXX: debugging code. Will need a generic way of tracing selected portions of pc
+    s2e()->getCorePlugin()->onTranslateBlockStart.connect(
+            sigc::mem_fun(*this, &SymDriveTranslationBlockTracer::onTranslateBlockStart)
+    );
+
+    s2e()->getCorePlugin()->onTranslateBlockEnd.connect(
+            sigc::mem_fun(*this, &SymDriveTranslationBlockTracer::onTranslateBlockEnd)
+    );
+#endif
+}
+
+#if 0
+void SymDriveTranslationBlockTracer::onTranslateBlockStart(
+        ExecutionSignal *signal,
+        S2EExecutionState* state,
+        TranslationBlock *tb,
+        uint64_t pc)
+{
+    uint64_t rlow = 0x4746c4 - 0x400000 + 0x804d7000;
+    uint64_t rhigh = 0x474e23 - 0x400000 + 0x804d7000;
+
+    if (pc >= rlow && pc <= rhigh) {
+    signal->connect(
+        sigc::mem_fun(*this, &SymDriveTranslationBlockTracer::onExecuteBlockStart)
+    );
+    }
+}
+
+void SymDriveTranslationBlockTracer::onTranslateBlockEnd(
+        ExecutionSignal *signal,
+        S2EExecutionState* state,
+        TranslationBlock *tb,
+        uint64_t endPc,
+        bool staticTarget,
+        uint64_t targetPc)
+{
+    uint64_t rlow = 0x4746c4 - 0x400000 + 0x804d7000;
+    uint64_t rhigh = 0x474e23 - 0x400000 + 0x804d7000;
+
+    if (endPc >= rlow && endPc <= rhigh) {
+        signal->connect(
+            sigc::mem_fun(*this, &SymDriveTranslationBlockTracer::onExecuteBlockEnd)
+        );
+    }
+}
+
+#endif
+
+void SymDriveTranslationBlockTracer::onModuleTranslateBlockStart(
+        ExecutionSignal *signal,
+        S2EExecutionState* state,
+        const ModuleDescriptor &module,
+        TranslationBlock *tb,
+        uint64_t pc)
+{
+    signal->connect(
+        sigc::mem_fun(*this, &SymDriveTranslationBlockTracer::onExecuteBlockStart)
+    );
+}
+
+void SymDriveTranslationBlockTracer::onModuleTranslateBlockEnd(
+        ExecutionSignal *signal,
+        S2EExecutionState* state,
+        const ModuleDescriptor &module,
+        TranslationBlock *tb,
+        uint64_t endPc,
+        bool staticTarget,
+        uint64_t targetPc)
+{
+    signal->connect(
+        sigc::mem_fun(*this, &SymDriveTranslationBlockTracer::onExecuteBlockEnd)
+    );
+}
+
+//The real tracing is done here
+//-----------------------------
+
+void SymDriveTranslationBlockTracer::trace(S2EExecutionState *state, uint64_t pc, ExecTraceEntryType type)
+{
+    ExecutionTraceTb tb;
+
+    if (type == TRACE_TB_START) {
+        if (pc != state->getTb()->pc) {
+            s2e()->getWarningsStream() << "BUG! pc=" << hexval(pc)
+                                       << " tbpc=" << hexval(state->getTb()->pc) << '\n';
+            exit(-1);
+        }
+    }
+
+    tb.pc = pc;
+    tb.targetPc = state->getPc();
+    tb.tbType = state->getTb()->s2e_tb_type;
+    tb.symbMask = 0;
+    tb.size = state->getTb()->size;
+    memset(tb.registers, 0x55, sizeof(tb.registers));
+
+    assert(sizeof(tb.symbMask)*8 >= sizeof(tb.registers)/sizeof(tb.registers[0]));
+    for (unsigned i=0; i<sizeof(tb.registers)/sizeof(tb.registers[0]); ++i) {
+        //XXX: make it portable across architectures
+        unsigned offset = offsetof(CPUX86State, regs) + i*sizeof(tb.registers[0]);
+        if (!state->readCpuRegisterConcrete(offset, &tb.registers[i], sizeof(tb.registers[0]))) {
+            tb.registers[i]  = 0xDEADBEEF;
+            tb.symbMask |= 1<<i;
+        }
+    }
+
+    m_tracer->writeData(state, &tb, sizeof(tb), type);
+
+}
+
+void SymDriveTranslationBlockTracer::onExecuteBlockStart(S2EExecutionState *state, uint64_t pc)
+{
+    trace(state, pc, TRACE_TB_START);
+}
+
+void SymDriveTranslationBlockTracer::onExecuteBlockEnd(S2EExecutionState *state, uint64_t pc)
+{
+    trace(state, pc, TRACE_TB_END);
+}
+
+} // namespace plugins
+} // namespace s2e
diff --git a/qemu/s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.h b/qemu/s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.h
new file mode 100644
index 0000000..047acae
--- /dev/null
+++ b/qemu/s2e/Plugins/SymDrive/SymDriveTranslationBlockTracer.h
@@ -0,0 +1,103 @@
+/*
+ * S2E Selective Symbolic Execution Framework
+ *
+ * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the Dependable Systems Laboratory, EPFL nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE DEPENDABLE SYSTEMS LABORATORY, EPFL BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Currently maintained by:
+ *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
+ *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
+ *
+ * All contributors are listed in S2E-AUTHORS file.
+ *
+ */
+
+#ifndef S2E_PLUGINS_SYMDRIVETBTRACER_H
+#define S2E_PLUGINS_SYMDRIVETBTRACER_H
+
+#include <s2e/Plugin.h>
+#include <s2e/Plugins/CorePlugin.h>
+#include <s2e/S2EExecutionState.h>
+
+#include "../ExecutionTracers/ExecutionTracer.h"
+#include "../ExecutionTracers/TraceEntries.h"
+#include <s2e/Plugins/ModuleExecutionDetector.h>
+
+namespace s2e {
+namespace plugins {
+
+class SymDriveTranslationBlockTracer : public Plugin
+{
+    S2E_PLUGIN
+public:
+    SymDriveTranslationBlockTracer(S2E* s2e): Plugin(s2e) {}
+
+    void initialize(void);
+
+
+private:
+    ExecutionTracer *m_tracer;
+    ModuleExecutionDetector *m_detector;
+
+    void onModuleTranslateBlockStart(
+            ExecutionSignal *signal,
+            S2EExecutionState* state,
+            const ModuleDescriptor &module,
+            TranslationBlock *tb,
+            uint64_t pc);
+
+    void onModuleTranslateBlockEnd(
+            ExecutionSignal *signal,
+            S2EExecutionState* state,
+            const ModuleDescriptor &module,
+            TranslationBlock *tb,
+            uint64_t endPc,
+            bool staticTarget,
+            uint64_t targetPc);
+
+    void onTranslateBlockStart(
+            ExecutionSignal *signal,
+            S2EExecutionState* state,
+            TranslationBlock *tb,
+            uint64_t pc);
+
+    void onTranslateBlockEnd(
+            ExecutionSignal *signal,
+            S2EExecutionState* state,
+            TranslationBlock *tb,
+            uint64_t endPc,
+            bool staticTarget,
+            uint64_t targetPc);
+
+    void trace(S2EExecutionState *state, uint64_t pc, ExecTraceEntryType type);
+
+    void onExecuteBlockStart(S2EExecutionState *state, uint64_t pc);
+    void onExecuteBlockEnd(S2EExecutionState *state, uint64_t pc);
+};
+
+} // namespace plugins
+} // namespace s2e
+
+#endif
diff --git a/qemu/s2e/Plugins/SymbolicHardware.cpp b/qemu/s2e/Plugins/SymbolicHardware.cpp
index 34a1e4f..5e504de 100644
--- a/qemu/s2e/Plugins/SymbolicHardware.cpp
+++ b/qemu/s2e/Plugins/SymbolicHardware.cpp
@@ -42,6 +42,7 @@ extern "C"
 #include "hw/isa.h"
 #include "hw/fakepci.h"
 #include "hw/sysbus.h"
+#include "hw/msi.h"
 #include "qemu/object.h"
 }
 
@@ -92,6 +93,12 @@ extern "C" {
 
     static void pci_symbhw_class_init(ObjectClass *klass, void *data);
     static void isa_symbhw_class_init(ObjectClass *klass, void *data);
+
+    // SymDrive Added these:
+    uint64_t symbhw_read(void *opaque, target_phys_addr_t addr,
+                         unsigned size);
+    void symbhw_write(void *opaque, target_phys_addr_t addr,
+                      uint64_t data, unsigned size);
 }
 
 
@@ -109,9 +116,25 @@ void SymbolicHardware::initialize()
     if (!ok || keys.empty()) {
         ws << "No symbolic device descriptor specified in " << getConfigKey() << "." <<
                 " S2E will start without symbolic hardware." << '\n';
-        return;
+        // return; // SymDrive
+    }
+    else {
+        // SymDrive added else
+        foreach2(it, keys.begin(), keys.end()) {
+            std::stringstream ss;
+            ss << getConfigKey() << "." << *it;
+            DeviceDescriptor *dd = DeviceDescriptor::create(this, cfg, ss.str());
+            if (!dd) {
+                ws << "Failed to create a symbolic device for " << ss.str() << "\n";
+                exit(-1);
+            }
+
+            dd->print(s2e()->getMessagesStream());
+            m_devices.insert(dd);
+        }
     }
 
+    /*
     foreach2(it, keys.begin(), keys.end()) {
         std::stringstream ss;
         ss << getConfigKey() << "." << *it;
@@ -124,6 +147,7 @@ void SymbolicHardware::initialize()
         dd->print(s2e()->getMessagesStream());
         m_devices.insert(dd);
     }
+    */
 
     s2e()->getCorePlugin()->onDeviceRegistration.connect(
         sigc::mem_fun(*this, &SymbolicHardware::onDeviceRegistration)
@@ -143,6 +167,10 @@ void SymbolicHardware::initialize()
         s2e()->getCorePlugin()->setPortCallback(symbhw_is_symbolic_none, this);
         s2e()->getCorePlugin()->setMmioCallback(symbhw_is_mmio_symbolic_none, this);
     }
+
+    // SymDrive
+    s2e()->getCorePlugin()->onCustomInstruction.connect(
+        sigc::mem_fun(*this, &SymbolicHardware::onCustomInstruction));
 }
 
 //XXX: Do it per-state!
@@ -176,7 +204,8 @@ bool SymbolicHardware::setSymbolicMmioRange(S2EExecutionState *state, uint64_t p
     s2e()->getDebugStream() << "SymbolicHardware: adding MMIO range 0x" << hexval(physaddr)
             << " length=0x" << size << '\n';
 
-    assert(state->isActive());
+   // SymDrive unsure as to whether we need this.
+   // assert(state->isActive()); // SymDrive this will fail during pci_restore_device???
 
     DECLARE_PLUGINSTATE(SymbolicHardwareState, state);
     bool b = plgState->setMmioRange(physaddr, size, true);
@@ -203,6 +232,64 @@ bool SymbolicHardware::isMmioSymbolic(uint64_t physaddress, uint64_t size) const
     return b;
 }
 
+// SymDrive:  added this
+void SymbolicHardware::onCustomInstruction(S2EExecutionState* state, uint64_t opcode)
+{
+    uint8_t opc = (opcode>>8) & 0xFF;
+    if (opc != 0xB1 && opc != 0xB2) {
+        return;
+    }
+
+    uint32_t phys_address, size, name; // XXX
+    bool ok = true;
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EAX]),
+                                         &phys_address, 4);
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_EBX]),
+                                         &size, 4);
+    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_ECX]),
+                                         &name, 4);
+
+    if(!ok) {
+        s2e()->getWarningsStream(state)
+            << "ERROR: symbolic argument was passed to s2e_op "
+            " insert_symbolic opcode\n";
+        return;
+    }
+
+    std::string nameStr;
+    if(!name || !state->readString(name, nameStr)) {
+        s2e()->getWarningsStream(state)
+            << "Error reading string from the guest\n";
+        nameStr = "defstr";
+    }
+    s2e()->getMessagesStream(state)
+        << "Managing symbolic data at " << hexval(phys_address)
+        << " of size " << hexval(size)
+        << " with name '" << nameStr << "'\n";
+
+    switch (opc) {
+        case 0xB1:
+        {
+            // s2e_make_dma_symbolic
+            // SymDrive -- this is a different kind of symbolic memory.
+            setSymbolicMmioRange(state, phys_address, size);
+            break;
+        }
+        case 0xB2:
+        {
+            // s2e_free_dma_symbolic
+            // SymDrive -- this is a different kind of symbolic memory.
+            resetSymbolicMmioRange(state, phys_address, size);
+            break;
+        }
+        default:
+        {
+            s2e()->getMessagesStream(state) << "Matt you idiot, you screwed this up.";
+            break;
+        }
+    }
+}
+
 static bool symbhw_is_symbolic(uint16_t port, void *opaque)
 {
     SymbolicHardware *hw = static_cast<SymbolicHardware*>(opaque);
@@ -297,7 +384,7 @@ DeviceDescriptor *DeviceDescriptor::create(SymbolicHardware *plg, ConfigFile *cf
 
     std::string id = cfg->getString(key + ".id", "", &ok);
     if (!ok || id.empty()) {
-        ws << "You must specifiy an id for " << key << ". " <<
+        ws << "You must specify an id for " << key << ". " <<
                 "This is required by QEMU for saving/restoring snapshots." << '\n';
         return NULL;
     }
@@ -458,46 +545,92 @@ PciDeviceDescriptor* PciDeviceDescriptor::create(SymbolicHardware *plg, ConfigFi
 {
     bool ok;
     llvm::raw_ostream &ws = plg->s2e()->getWarningsStream();
+    llvm::raw_ostream &ms = plg->s2e()->getMessagesStream();
 
     std::string id = cfg->getString(key + ".id", "", &ok);
     assert(ok);
 
     uint16_t vid = cfg->getInt(key + ".vid", 0, &ok);
     if (!ok) {
-        ws << "You must specifiy a vendor id for a symbolic PCI device!" << '\n';
+        ws << "You must specify a vendor id for a symbolic PCI device!" << '\n';
         return NULL;
     }
 
     uint16_t pid = cfg->getInt(key + ".pid", 0, &ok);
     if (!ok) {
-        ws << "You must specifiy a product id for a symbolic PCI device!" << '\n';
+        ws << "You must specify a product id for a symbolic PCI device!" << '\n';
         return NULL;
     }
 
+    uint16_t ss_vid = cfg->getInt(key + ".ss_vid", 0, &ok); // SymDrive added this
+    if (!ok) {
+        ms << "Defaulting to ss_vid of 0\n";
+        ss_vid = 0;
+    }
+
+    uint16_t ss_id = cfg->getInt(key + ".ss_id", 0, &ok); // SymDrive added this
+    if (!ok) {
+        ms << "Defaulting to ss_id of 0\n";
+        ss_id = 0;
+    }
+
     uint32_t classCode = cfg->getInt(key + ".classCode", 0, &ok);
     if (!ok || classCode > 0xffffff) {
-        ws << "You must specifiy a valid class code for a symbolic PCI device!" << '\n';
+        ws << "You must specify a valid class code for a symbolic PCI device!" << '\n';
         return NULL;
     }
 
     uint8_t revisionId = cfg->getInt(key + ".revisionId", 0, &ok);
     if (!ok) {
-        ws << "You must specifiy a revision id for a symbolic PCI device!" << '\n';
+        ws << "You must specify a revision id for a symbolic PCI device!" << '\n';
         return NULL;
     }
 
     uint8_t interruptPin = cfg->getInt(key + ".interruptPin", 0, &ok);
     if (!ok || interruptPin > 4) {
-        ws << "You must specifiy an interrupt pin (1-4, 0 for none) for " << key << "!" << '\n';
+        ws << "You must specify an interrupt pin (1-4, 0 for none) for " << key << "!" << '\n';
         return NULL;
     }
 
+    uint32_t capPM = cfg->getInt(key + ".cap_pm", 0, &ok); // SymDrive
+    if (!ok) {
+        ms << "Defaulting to capPM = 0\n";
+        capPM = 0;
+    } else {
+        if (capPM != 0 && capPM != 1) {
+            ws << "You must specify 0 or 1 for capPM, " << key << "!" << '\n';
+            return NULL;
+        }
+    }
+
+    uint32_t capMSI = cfg->getInt(key + ".cap_msi", 0, &ok); // SymDrive
+    if (!ok) {
+        ms << "Defaulting to capMSI = 0\n";
+        capMSI = 0;
+    } else {
+        if (capMSI > 4096) {
+            ws << "You must specify MSI >= 0 and <= 4096 for capMSI, " << key << "!" << '\n';
+            return NULL;
+        }
+    }
+
+    uint32_t capPCIE = cfg->getInt(key + ".cap_pcie", 0, &ok); // SymDrive
+    if (!ok) {
+        ms << "Defaulting to capPCIE = 0\n";
+        capPCIE = 0;
+    } else {
+        if (capPCIE != 0 && capPCIE != 1) {
+            ws << "You must specify 0 or 1 for capPCIE, " << key << "!" << '\n';
+            return NULL;
+        }
+    }
+
     std::vector<PciResource> resources;
 
     //Reading the resource list
     ConfigFile::string_list resKeys = cfg->getListKeys(key + ".resources", &ok);
     if (!ok || resKeys.empty()) {
-        ws << "You must specifiy at least one resource descriptor for a symbolic PCI device!" << '\n';
+        ws << "You must specify at least one resource descriptor for a symbolic PCI device!" << '\n';
         return NULL;
     }
 
@@ -539,13 +672,43 @@ PciDeviceDescriptor* PciDeviceDescriptor::create(SymbolicHardware *plg, ConfigFi
     ret->m_classCode = classCode;
     ret->m_pid = pid;
     ret->m_vid = vid;
+    ret->m_ss_vid = ss_vid;
+    ret->m_ss_id = ss_id;
     ret->m_revisionId = revisionId;
     ret->m_interruptPin = interruptPin;
+    ret->m_capPM = capPM;
+    ret->m_capMSI = capMSI;
+    ret->m_capPCIE = capPCIE;
     ret->m_resources = resources;
 
     return ret;
 }
 
+static int SymDrive_fakepci_post_load(void *opaque, int version_id) {
+    SymbolicPciDeviceState *hw1 = static_cast<SymbolicPciDeviceState*>(opaque);
+    SymbolicHardware *hw2 = (SymbolicHardware*)g_s2e->getPlugin("SymbolicHardware");
+    assert (hw1);
+    assert (hw2);
+
+    int i = 0;
+    for (i = 0; i < PCI_NUM_REGIONS; i++) {
+        if (hw1->dev.io_regions[i].memory == NULL ||
+            hw1->dev.io_regions[i].address_space == NULL) {
+            continue;
+        }
+
+        int type = hw1->dev.io_regions[i].type;
+
+        if (type & PCI_BASE_ADDRESS_SPACE_IO) {
+            hw2->setSymbolicPortRange(hw1->dev.io_regions[i].addr, hw1->dev.io_regions[i].size, true);
+            // Port I/O
+        } else {
+            // MMIO
+        }
+    }
+
+    return 0;
+}
 
 void PciDeviceDescriptor::initializeQemuDevice()
 {
@@ -583,7 +746,12 @@ void PciDeviceDescriptor::initializeQemuDevice()
     //Replaces VMSTATE_PCI_DEVICE()
     m_vmStateFields[0].name = m_id.c_str();
     m_vmStateFields[0].size = sizeof(PCIDevice);
-    m_vmStateFields[0].vmsd = &vmstate_pci_device;
+    if (m_capPCIE > 0) {
+        m_vmStateFields[0].version_id = 2;
+        m_vmStateFields[0].vmsd = &vmstate_pcie_device;
+    } else {
+        m_vmStateFields[0].vmsd = &vmstate_pci_device;
+    }
     m_vmStateFields[0].flags = VMS_STRUCT;
     m_vmStateFields[0].offset = vmstate_offset_value(SymbolicPciDeviceState, dev, PCIDevice);
 
@@ -595,6 +763,7 @@ void PciDeviceDescriptor::initializeQemuDevice()
     m_vmState->minimum_version_id = 3,
     m_vmState->minimum_version_id_old = 3,
     m_vmState->fields = m_vmStateFields;
+    m_vmState->post_load = SymDrive_fakepci_post_load; // SymDrive
 
     type_register_static(m_devInfo);
 }
@@ -633,6 +802,9 @@ PciDeviceDescriptor::PciDeviceDescriptor(const std::string &id):DeviceDescriptor
     m_classCode = 0;
     m_revisionId = 0;
     m_interruptPin = 0;
+    m_capPM = 0;
+    m_capMSI = 0;
+    m_capPCIE = 0;
 }
 
 PciDeviceDescriptor::~PciDeviceDescriptor()
@@ -645,10 +817,15 @@ void PciDeviceDescriptor::print(llvm::raw_ostream &os) const
     os << "PCI Device Descriptor id=" << m_id << '\n';
     os << "VID=" << hexval(m_vid) <<
             " PID=" << hexval(m_pid) <<
+        " SS_VID=0x" << m_ss_vid << // SymDrive
+        " SS_ID=0x" << m_ss_id << // SymDrive
             " RevID=" << hexval(m_revisionId) << '\n';
 
     os << "Class=" << hexval(m_classCode) <<
             " INT=" << hexval(m_interruptPin) << '\n';
+    os << "capPM=" << hexval(m_capPM) << "\n";
+    os << "capMSI=" << hexval(m_capMSI) << "\n";
+    os << "capPCIE=" << hexval(m_capPCIE) << "\n";
 
     unsigned i=0;
     foreach2(it, m_resources.begin(), m_resources.end()) {
@@ -683,19 +860,14 @@ void PciDeviceDescriptor::assignIrq(void *irq)
 
 /////////////////////////////////////////////////////////////////////
 /* Dummy I/O functions for symbolic devices. Unused for now. */
-
-/////////////////////////////////////////////////////////////////////
-/* Dummy I/O functions for symbolic devices. Unused for now. */
-static uint64_t symbhw_read(void *opaque, target_phys_addr_t addr,
-                            unsigned size)
-{
+/* static SymDrive */ uint64_t symbhw_read(void *opaque, target_phys_addr_t addr,
+                            unsigned size) {
     return 0;
 }
 
-static void symbhw_write(void *opaque, target_phys_addr_t addr,
-                         uint64_t data, unsigned size)
-{
-
+/* static SymDrive */ void symbhw_write(void *opaque, target_phys_addr_t addr,
+                         uint64_t data, unsigned size) {
+    return;
 }
 
 static const MemoryRegionOps symbhw_io_ops = {
@@ -776,7 +948,59 @@ static int pci_symbhw_init(PCIDevice *pci_dev)
 
     pci_conf = symb_pci_state->dev.config;
     pci_conf[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
-    pci_conf[0x3d] = pci_device_desc->getInterruptPin(); // interrupt pin 0
+    // SymDrive --------->
+    pci_set_byte(&pci_conf[PCI_INTERRUPT_PIN], pci_device_desc->getInterruptPin());
+    pci_set_byte(&pci_conf[PCI_REVISION_ID], pci_device_desc->getRevisionId());
+
+    // Force PCI power management to ON
+    // We could add a flag for this.
+    if (pci_device_desc->getCapPM() > 0) {
+        int r = pci_add_capability(pci_dev, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF);
+        assert (r >= 0 && "Why isn't power management working?");
+    }
+
+    if (pci_device_desc->getCapMSI() > 0) {
+        // The 0 = find a valid PCI capability offset.
+        // 0x50 seems to work FWIW
+        // The first 64 bytes of PCI config space are
+        // standardized, so 0x50 = the first byte after that.
+        // If we add more capabilities this number might need
+        // to be changed.
+        // false = msi64bit (4th param)
+        // false = msi_per_vector_mask (5th param)
+        msi_init(pci_dev, 0, pci_device_desc->getCapMSI(), false, false);
+    } else {
+        assert (pci_device_desc->getCapMSI() == 0 && "?? MSI should be >= 0");
+    }
+
+    if (pci_device_desc->getCapPCIE() > 0) {
+        // TODO:  I have no idea if we should be using PCI_EXP_TYPE_ENDPOINT
+        // and I also have no idea if 0 is a reasonable "port" number.
+        // We're basically am just calling this function and hoping for the best.
+        int r = pcie_cap_init(pci_dev, 0, PCI_EXP_TYPE_ENDPOINT, 0);
+        assert (r >= 0 && "Why isn't PCI-E working?");
+    }
+
+    if (pci_device_desc->getCapPM() > 0) {
+        uint8_t cap;
+        cap = pci_find_capability(pci_dev, PCI_CAP_ID_PM);
+        g_s2e->getMessagesStream() << "capPM offset: " << hexval(cap) << "\n";
+        assert (cap != 0 && "cap PM bug.");
+    }
+    if (pci_device_desc->getCapMSI() > 0) {
+        uint8_t cap;
+        cap = pci_find_capability(pci_dev, PCI_CAP_ID_MSI);
+        g_s2e->getMessagesStream() << "capMSI offset: " << hexval(cap) << "\n";
+        assert (cap != 0 && "cap MSI bug.");
+    }
+    if (pci_device_desc->getCapPCIE() > 0) {
+        uint8_t cap;
+        cap = pci_find_capability(pci_dev, PCI_CAP_ID_EXP);
+        g_s2e->getMessagesStream() << "capPCIE offset: " << hexval(cap) << "\n";
+        assert (cap != 0 && "cap PCI-E bug.");
+    }
+    // SymDrive <---------
+
 
     const PciDeviceDescriptor::PciResources &resources =
             pci_device_desc->getResources();
@@ -794,12 +1018,13 @@ static int pci_symbhw_init(PCIDevice *pci_dev)
 
         if (type & PCI_BASE_ADDRESS_SPACE_IO) {
             ss << "-io";
-        } else if (type & PCI_BASE_ADDRESS_SPACE_MEMORY) {
+        } else /* if (type & PCI_BASE_ADDRESS_SPACE_MEMORY) SymDrive */ {
             ss << "-mmio";
         }
 
         memory_region_init_io(&symb_pci_state->io[i], &symbhw_io_ops, symb_pci_state, ss.str().c_str(), res.size);
         pci_register_bar(&symb_pci_state->dev, i, type, &symb_pci_state->io[i]);
+
         ++i;
     }
 
@@ -812,6 +1037,18 @@ static int pci_symbhw_uninit(PCIDevice *pci_dev)
 {
     SymbolicPciDeviceState *d = DO_UPCAST(SymbolicPciDeviceState, dev, pci_dev);
 
+    // PM support requires no special shutdown
+
+    // MSI support
+    if (d->desc->getCapMSI() > 0) {
+        msi_uninit(pci_dev);
+    }
+
+    // PCI-E support
+    if (d->desc->getCapPCIE() > 0) {
+        pcie_cap_exit(pci_dev);
+    }
+
     for (int i=0; i<d->desc->getResources().size(); ++i) {
         memory_region_destroy(&d->io[i]);
     }
@@ -825,7 +1062,10 @@ static void  pci_symbhw_class_init(ObjectClass *klass, void *data)
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
     PciDeviceDescriptor *pci_desc = static_cast<PciDeviceDescriptor*>(data);
-
+    if (pci_desc->getCapPCIE() > 0) {
+        k->is_express = 1;
+    }
+    
     k->init = pci_symbhw_init;
     k->exit = pci_symbhw_uninit;
 
@@ -939,10 +1179,12 @@ bool SymbolicHardwareState::PageBitmap::hasSymbolic() const
 }
 
 void SymbolicHardwareState::PageBitmap::allocateBitmap(klee::BitArray *source) {
-    if (source) {
-        bitmap = new klee::BitArray(*source, TARGET_PAGE_SIZE);
-    } else {
-        bitmap = new klee::BitArray(TARGET_PAGE_SIZE, false);
+    if (bitmap == NULL) { // SymDrive
+        if (source) {
+            bitmap = new klee::BitArray(*source, TARGET_PAGE_SIZE);
+        } else {
+            bitmap = new klee::BitArray(TARGET_PAGE_SIZE, false);
+        }
     }
 }
 
@@ -979,6 +1221,7 @@ SymbolicHardwareState::PageBitmap::~PageBitmap() {
     if (bitmap) {
         delete bitmap;
     }
+    bitmap = NULL; // SymDrive
 }
 
 //Returns true if the resulting range is fully concrete
diff --git a/qemu/s2e/Plugins/SymbolicHardware.h b/qemu/s2e/Plugins/SymbolicHardware.h
index 7c7e5fd..933119b 100644
--- a/qemu/s2e/Plugins/SymbolicHardware.h
+++ b/qemu/s2e/Plugins/SymbolicHardware.h
@@ -160,6 +160,9 @@ private:
     uint32_t m_classCode;
     uint8_t m_revisionId;
     uint8_t m_interruptPin;
+    uint32_t m_capPM;
+    uint32_t m_capMSI;
+    uint32_t m_capPCIE;
     PciResources m_resources;
 
     PciDeviceDescriptor(const std::string &id);
@@ -176,6 +179,11 @@ public:
     uint8_t getRevisionId() const { return m_revisionId; }
     uint8_t getInterruptPin() const { return m_interruptPin; }
 
+    // Capabilities
+    uint32_t getCapPM() const { return m_capPM; }
+    uint32_t getCapMSI() const { return m_capMSI; }
+    uint32_t getCapPCIE() const { return m_capPCIE; }
+
     const PciResources& getResources() const { return m_resources; }
     static PciDeviceDescriptor* create(SymbolicHardware *plg, ConfigFile *cfg, const std::string &key);
 
@@ -212,6 +220,7 @@ public:
     bool isSymbolic(uint16_t port) const;
 
     bool isMmioSymbolic(uint64_t physaddress, uint64_t size) const;
+    void onCustomInstruction(S2EExecutionState* state, uint64_t opcode); // SymDrive
     bool setSymbolicMmioRange(S2EExecutionState *state, uint64_t physaddr, uint64_t size);
     bool resetSymbolicMmioRange(S2EExecutionState *state, uint64_t physaddr, uint64_t size);
 private:
diff --git a/qemu/s2e/S2E.cpp b/qemu/s2e/S2E.cpp
index de7915d..384ef36 100644
--- a/qemu/s2e/S2E.cpp
+++ b/qemu/s2e/S2E.cpp
@@ -607,7 +607,9 @@ llvm::raw_ostream& S2E::getStream(llvm::raw_ostream &stream,
             stream  << "[Node " << m_currentProcessIndex <<
                     "/" << m_currentProcessId << " - State " << state->getID() << "] ";
         }else {
-            stream << "[State " << state->getID() << "] ";
+            stream << "[" << state->getID() << "/" // MJR
+                   << m_s2eExecutor->getStatesCount() << "] ";
+            // stream << "[State " << state->getID() << "] ";  // MJR
         }
     }
     return stream;
diff --git a/qemu/s2e/S2E.h b/qemu/s2e/S2E.h
index d7f9339..616ea73 100644
--- a/qemu/s2e/S2E.h
+++ b/qemu/s2e/S2E.h
@@ -207,6 +207,7 @@ public:
     /***********************/
     /* Runtime information */
     S2EExecutor* getExecutor() { return m_s2eExecutor; }
+    const S2EExecutor* getExecutor() const { return m_s2eExecutor; }
 
     //XXX: A plugin can hold cached state information. When a state is deleted,
     //remove all the cached info from all plugins.
diff --git a/qemu/s2e/S2EExecutionState.cpp b/qemu/s2e/S2EExecutionState.cpp
index d7991ea..ac6477a 100644
--- a/qemu/s2e/S2EExecutionState.cpp
+++ b/qemu/s2e/S2EExecutionState.cpp
@@ -1166,6 +1166,7 @@ ref<Expr> S2EExecutionState::createSymbolicValue(
 {
 
     std::vector<unsigned char> concreteValues;
+    // concreteValues.resize(Expr::getMinBytesForWidth(width)); // MJR added this line
     return createConcolicValue(name, width, concreteValues);
 }
 
@@ -1835,3 +1836,4 @@ int s2e_is_runnable(S2EExecutionState *state)
 }
 
 } // extern "C"
+
diff --git a/qemu/s2e/S2EExecutor.cpp b/qemu/s2e/S2EExecutor.cpp
index 12df7a0..9a873b1 100644
--- a/qemu/s2e/S2EExecutor.cpp
+++ b/qemu/s2e/S2EExecutor.cpp
@@ -159,7 +159,7 @@ namespace {
     cl::opt<unsigned>
     MaxForksOnConcretize("max-forks-on-concretize",
             cl::desc("Maximum number of states to fork when concretizing symbolic value"),
-            cl::init(256));
+                         cl::init(3)); // MJR
 
     cl::opt<bool>
     FlushTBsOnStateSwitch("flush-tbs-on-state-switch",
@@ -390,29 +390,103 @@ void S2EHandler::processTestCase(const klee::ExecutionState &state,
     //Use onTestCaseGeneration event instead.
 }
 
+void S2EExecutor::handlerMJRCommon(Executor* executor,
+                                   ExecutionState* state,
+                                   klee::KInstruction* target,
+                                   int accessType,
+                                   std::vector<klee::ref<klee::Expr> > &args) {
+    assert(dynamic_cast<S2EExecutor*>(executor));
+    S2EExecutor* s2eExecutor = static_cast<S2EExecutor*>(executor);
+
+    // MJR This call corresponds to tcg_llvm_trace_memory_access
+    // tcg_llvm_trace_memory_access parameters are:
+    // vaddr, value, sizeof(value), isWrite
+    // MJR Added for I/O memory tracing:
+    if(!s2eExecutor->m_s2e->getCorePlugin()->onIOMemoryAccess.empty()) {
+        assert(dynamic_cast<S2EExecutionState*>(state));
+        assert(args.size() == 4);
+
+        S2EExecutionState* s2eState = static_cast<S2EExecutionState*>(state);
+
+        // Argument index 0 is the address
+        klee::ref<klee::Expr> vaddr = args[0];
+
+        // Argument index 2 is size in bits:
+        Expr::Width sizeInBits = cast<klee::ConstantExpr>(args[2])->getZExtValue();
+        Expr::Width sizeInBytes = sizeInBits / 8;
+
+        // Argument index 1 is value:
+        klee::ref<Expr> value = klee::ExtractExpr::create(args[1], 0, sizeInBits);
+
+        // Argument index 3 is whether it's a write operation or not
+        bool isWrite = cast<klee::ConstantExpr>(args[3])->getZExtValue();
+
+        s2eExecutor->m_s2e->getCorePlugin()->onIOMemoryAccess.emit(
+            s2eState,
+            accessType,
+            vaddr,            // address
+            value,            // value
+            sizeInBytes,      // size converted to bytes
+            isWrite);         // true = write, false = read
+    }
+}
+
 void S2EExecutor::handlerTraceMemoryAccess(Executor* executor,
+                                           ExecutionState* state,
+                                           klee::KInstruction* target,
+                                           std::vector<klee::ref<klee::Expr> > &args)
+{
+    handlerMJRCommon(executor, state, target, 1, args);
+}
+
+void S2EExecutor::handlerTracePortAccess(Executor* executor,
                                      ExecutionState* state,
                                      klee::KInstruction* target,
                                      std::vector<klee::ref<klee::Expr> > &args)
 {
-    assert(dynamic_cast<S2EExecutor*>(executor));
+    // assert(dynamic_cast<S2EExecutor*>(executor));
+    // S2EExecutor* s2eExecutor = static_cast<S2EExecutor*>(executor);
 
-    S2EExecutor* s2eExecutor = static_cast<S2EExecutor*>(executor);
-    if(!s2eExecutor->m_s2e->getCorePlugin()->onDataMemoryAccess.empty()) {
-        assert(dynamic_cast<S2EExecutionState*>(state));
-        S2EExecutionState* s2eState = static_cast<S2EExecutionState*>(state);
+    // if(!s2eExecutor->m_s2e->getCorePlugin()->onIOMemoryAccess.empty()) {
+    //     assert(dynamic_cast<S2EExecutionState*>(state));
+    //     assert(args.size() == 4);
 
-        assert(args.size() == 6);
+    //     S2EExecutionState* s2eState = static_cast<S2EExecutionState*>(state);
+    //     int accessType = 0; // Port I/O
 
-        Expr::Width width = cast<klee::ConstantExpr>(args[3])->getZExtValue();
-        bool isWrite = cast<klee::ConstantExpr>(args[4])->getZExtValue();
-        bool isIO    = cast<klee::ConstantExpr>(args[5])->getZExtValue();
+    //     // The indexes into the args array correspond with the parameters
+    //     // passed to the tcg_llvm_trace_port_access function
+    //     // Argument index 0 is the port number
+    //     ref<Expr> port = args[0];
 
-        ref<Expr> value = klee::ExtractExpr::create(args[2], 0, width);
+    //     // Argument index 2 is the size in bytes:
+    //     int sizeInBytes = cast<klee::ConstantExpr>(args[2])->getZExtValue();
+    //     Expr::Width sizeInBits = sizeInBytes * 8;
 
-        s2eExecutor->m_s2e->getCorePlugin()->onDataMemoryAccess.emit(
-                s2eState, args[0], args[1], value, isWrite, isIO);
-    }
+    //     // Argument index 1 is the value:
+    //     ref<Expr> value = klee::ExtractExpr::create(args[1], 0, sizeInBits);
+
+    //     // Argument index 3 is whether it's a write operation or not
+    //     bool isWrite = cast<klee::ConstantExpr>(args[3])->getZExtValue();
+
+    //     s2eExecutor->m_s2e->getCorePlugin()->onIOMemoryAccess.emit(
+    //         s2eState,
+    //         accessType,
+    //         port,
+    //         value,
+    //         sizeInBytes,
+    //         isWrite);
+    // }
+
+    handlerMJRCommon(executor, state, target, 0, args);
+}
+
+void S2EExecutor::handlerTraceDMAAccess(Executor* executor,
+                                        ExecutionState* state,
+                                        klee::KInstruction* target,
+                                        std::vector<klee::ref<klee::Expr> > &args)
+{
+    handlerMJRCommon(executor, state, target, 2, args);
 }
 
 void S2EExecutor::handlerTraceInstruction(klee::Executor* executor,
@@ -458,31 +532,6 @@ void S2EExecutor::handlerOnTlbMiss(Executor* executor,
     s2e_on_tlb_miss(g_s2e, s2eState, constAddress, isWrite);
 }
 
-void S2EExecutor::handlerTracePortAccess(Executor* executor,
-                                     ExecutionState* state,
-                                     klee::KInstruction* target,
-                                     std::vector<klee::ref<klee::Expr> > &args)
-{
-    assert(dynamic_cast<S2EExecutor*>(executor));
-
-    S2EExecutor* s2eExecutor = static_cast<S2EExecutor*>(executor);
-
-    if(!s2eExecutor->m_s2e->getCorePlugin()->onPortAccess.empty()) {
-        assert(dynamic_cast<S2EExecutionState*>(state));
-        S2EExecutionState* s2eState = static_cast<S2EExecutionState*>(state);
-
-        assert(args.size() == 4);
-
-        Expr::Width width = cast<klee::ConstantExpr>(args[2])->getZExtValue();
-        bool isWrite = cast<klee::ConstantExpr>(args[3])->getZExtValue();
-
-        ref<Expr> value = klee::ExtractExpr::create(args[1], 0, width);
-
-        s2eExecutor->m_s2e->getCorePlugin()->onPortAccess.emit(
-                s2eState, args[0], value, isWrite);
-    }
-}
-
 void S2EExecutor::handleForkAndConcretize(Executor* executor,
                                      ExecutionState* state,
                                      klee::KInstruction* target,
@@ -757,6 +806,8 @@ S2EExecutor::S2EExecutor(S2E* s2e, TCGLLVMContext *tcgLLVMContext,
 
     __DEFINE_EXT_FUNCTION(s2e_ismemfunc)
     __DEFINE_EXT_FUNCTION(s2e_notdirty_mem_write)
+        __DEFINE_EXT_FUNCTION(s2e_issymfunc) // MJR
+        __DEFINE_EXT_FUNCTION(s2e_establishIOMap) // MJR
 
     __DEFINE_EXT_FUNCTION(cpu_io_recompile)
     __DEFINE_EXT_FUNCTION(can_do_io)
@@ -857,9 +908,10 @@ S2EExecutor::S2EExecutor(S2E* s2e, TCGLLVMContext *tcgLLVMContext,
     if (!execute_llvm) {
         Function* function;
 
-        function = kmodule->module->getFunction("tcg_llvm_trace_memory_access");
-        assert(function);
-        addSpecialFunctionHandler(function, handlerTraceMemoryAccess);
+        // MJR
+        //function = kmodule->module->getFunction("tcg_llvm_trace_memory_access");
+        //assert(function);
+        //addSpecialFunctionHandler(function, handlerTraceMemoryAccess);
 
         function = kmodule->module->getFunction("tcg_llvm_trace_port_access");
         assert(function);
@@ -1140,9 +1192,9 @@ void S2EExecutor::switchToConcrete(S2EExecutionState *state)
     if (m_forceConcretizations) {
         //XXX: Find a adhoc dirty way to implement overconstrained consistency model
         //There should be a consistency plugin somewhere else
-        s2e::plugins::ModuleExecutionDetector *md =
-                dynamic_cast<s2e::plugins::ModuleExecutionDetector*>(m_s2e->getPlugin("ModuleExecutionDetector"));
-        if (md && !md->getCurrentDescriptor(state)) {
+        //s2e::plugins::ModuleExecutionDetector *md = // MJR commented out
+        //        dynamic_cast<s2e::plugins::ModuleExecutionDetector*>(m_s2e->getPlugin("ModuleExecutionDetector"));
+        //if (md && !md->getCurrentDescriptor(state)) { // MJR We don't need this here
 
             if(!wos->isAllConcrete()) {
                 /* The object contains symbolic values. We have to
@@ -1157,7 +1209,7 @@ void S2EExecutor::switchToConcrete(S2EExecutionState *state)
                     }
                 }
             }
-        }
+            // } // MJR
     }
 
     //assert(os->isAllConcrete());
@@ -2182,7 +2234,7 @@ S2EExecutor::StatePair S2EExecutor::fork(ExecutionState &current,
                             ref<Expr> condition, bool isInternal)
 {
     assert(dynamic_cast<S2EExecutionState*>(&current));
-    assert(!static_cast<S2EExecutionState*>(&current)->m_runningConcrete);
+    // assert(!static_cast<S2EExecutionState*>(&current)->m_runningConcrete); // MJR moved below
 
     StatePair res;
 
@@ -2196,6 +2248,7 @@ S2EExecutor::StatePair S2EExecutor::fork(ExecutionState &current,
 
         assert(dynamic_cast<S2EExecutionState*>(res.first));
         assert(dynamic_cast<S2EExecutionState*>(res.second));
+        assert(!static_cast<S2EExecutionState*>(&current)->m_runningConcrete); // MJR moved from above
 
         std::vector<S2EExecutionState*> newStates(2);
         std::vector<ref<Expr> > newConditions(2);
@@ -2332,7 +2385,6 @@ void S2EExecutor::yieldState(ExecutionState &s)
 
     // Skip the opcode
     state.writeCpuState(CPU_OFFSET(eip), state.getPc() + 10, 32);
-
     // Stop current execution
     state.writeCpuState(CPU_OFFSET(exception_index), EXCP_S2E, 8*sizeof(int));
     throw CpuExitException();
@@ -2498,6 +2550,14 @@ void S2EExecutor::updateStats(S2EExecutionState *state)
     processTimers(state, 0);
 }
 
+std::set<ExecutionState *> &S2EExecutor::MJRGetAllStates(void) { // MJR
+    return states;
+}
+
+const std::set<ExecutionState *> &S2EExecutor::MJRGetAllStates(void) const { // MJR
+    return states;
+}
+
 } // namespace s2e
 
 /******************************/
diff --git a/qemu/s2e/S2EExecutor.h b/qemu/s2e/S2EExecutor.h
index f82958e..b827240 100644
--- a/qemu/s2e/S2EExecutor.h
+++ b/qemu/s2e/S2EExecutor.h
@@ -154,7 +154,6 @@ public:
                                 = std::vector<klee::ref<klee::Expr> >());
 
     /* Functions to be called mainly from QEMU */
-
     S2EExecutionState* selectNextState(S2EExecutionState* state);
     klee::ExecutionState* selectNonSpeculativeState(S2EExecutionState *state);
 
@@ -205,6 +204,8 @@ public:
     void initializeStatistics();
 
     void updateStats(S2EExecutionState *state);
+    std::set<klee::ExecutionState *> &MJRGetAllStates (void); // MJR
+    const std::set<klee::ExecutionState *> &MJRGetAllStates (void) const; // MJR
 
     bool isLoadBalancing() const {
         return m_inLoadBalancing;
@@ -220,10 +221,25 @@ public:
     }
 
 protected:
+public: // MJR
+    static void handlerMJRCommon(klee::Executor* executor,
+                                 klee::ExecutionState* state,
+                                 klee::KInstruction* target,
+                                 int accessType,
+                                 std::vector<klee::ref<klee::Expr> > &args);
     static void handlerTraceMemoryAccess(klee::Executor* executor,
-                                    klee::ExecutionState* state,
-                                    klee::KInstruction* target,
-                                    std::vector<klee::ref<klee::Expr> > &args);
+                                         klee::ExecutionState* state,
+                                         klee::KInstruction* target,
+                                         std::vector<klee::ref<klee::Expr> > &args);
+    static void handlerTracePortAccess(klee::Executor* executor,
+                                       klee::ExecutionState* state,
+                                       klee::KInstruction* target,
+                                       std::vector<klee::ref<klee::Expr> > &args);
+    static void handlerTraceDMAAccess(klee::Executor* executor,
+                                      klee::ExecutionState* state,
+                                      klee::KInstruction* target,
+                                      std::vector<klee::ref<klee::Expr> > &args);
+  protected: // MJR moved
 
     //Traces every single LLVM instruction in dyngend code
     static void handlerTraceInstruction(klee::Executor* executor,
@@ -231,11 +247,6 @@ protected:
                                     klee::KInstruction* target,
                                     std::vector<klee::ref<klee::Expr> > &args);
 
-    static void handlerTracePortAccess(klee::Executor* executor,
-                                         klee::ExecutionState* state,
-                                         klee::KInstruction* target,
-                                         std::vector<klee::ref<klee::Expr> > &args);
-
     static void handlerOnTlbMiss(klee::Executor* executor,
                                          klee::ExecutionState* state,
                                          klee::KInstruction* target,
diff --git a/qemu/s2e/s2e_qemu.h b/qemu/s2e/s2e_qemu.h
index 29f324d..adfe3db 100644
--- a/qemu/s2e/s2e_qemu.h
+++ b/qemu/s2e/s2e_qemu.h
@@ -147,8 +147,9 @@ void s2e_on_exception(unsigned intNb);
 
 /** Called on memory accesses from generated code */
 void s2e_trace_memory_access(
-        uint64_t vaddr, uint64_t haddr, uint8_t* buf, unsigned size,
-        int isWrite, int isIO);
+        struct S2E *s2e, struct S2EExecutionState* state, // MJR
+        uint64_t vaddr, /* uint64_t haddr, MJR */ uint8_t* buf, unsigned size,
+        int isWrite /*, int isIO MJR */);
 
 /** Called on port access from helper code */
 void s2e_trace_port_access(
@@ -328,6 +329,8 @@ void s2e_on_initialization_complete(void);
 
 void s2e_on_monitor_event(struct QDict *ret);
 
+void s2e_establishIOMap(int prefix, uint32_t port, uint32_t pc, uint32_t unique_id); // MJR added
+
 //XXX: Provide a means of including KLEE header
 /* Return a possible constant value for the input expression. This
    allows programs to forcibly concretize values on their own. */
@@ -349,9 +352,9 @@ int s2e_is_forking();
 uint64_t tcg_llvm_fork_and_concretize(uint64_t value,
                                       uint64_t knownMin,
                                       uint64_t knownMax);
-void tcg_llvm_trace_memory_access(uint64_t vaddr, uint64_t haddr,
-                                  uint64_t value, uint32_t bits,
-                                  uint8_t isWrite, uint8_t isIo);
+void tcg_llvm_trace_memory_access(uint64_t vaddr, /* uint64_t haddr, MJR */
+                                  uint64_t value, uint32_t /* bits MJR */ sizeInBytes,
+                                  uint8_t isWrite /*, uint8_t isIo MJR */);
 void tcg_llvm_trace_port_access(uint64_t port, uint64_t value,
                                 unsigned bits, int isWrite);
 //#endif
diff --git a/qemu/softmmu_defs.h b/qemu/softmmu_defs.h
index 5772f03..9c1bd57 100644
--- a/qemu/softmmu_defs.h
+++ b/qemu/softmmu_defs.h
@@ -146,9 +146,10 @@ int s2e_ismemfunc(struct MemoryRegion *mr, int isWrite);
 
 uintptr_t s2e_notdirty_mem_write(target_phys_addr_t ram_addr);
 int s2e_ismemfunc(struct MemoryRegion *mr, int isWrite);
-
+int s2e_issymfunc(struct MemoryRegion *opaque, target_ulong addr); // MJR
 
 #endif
 
+extern int g_tracing_enabled; // MJR                                                                                   
 
 #endif
diff --git a/qemu/softmmu_header.h b/qemu/softmmu_header.h
index afa0193..67f7e43 100644
--- a/qemu/softmmu_header.h
+++ b/qemu/softmmu_header.h
@@ -196,7 +196,7 @@ glue(glue(glue(CPU_PREFIX, ld), USUFFIX), MEMSUFFIX)(ENV_PARAM
 
         //XXX: Fix this to be on the dataflow
         //res = S2E_TRACE_MEMORY(addr, physaddr, res, 0, 0);
-        S2E_TRACE_MEMORY(addr, physaddr, res, 0, 0);
+        // S2E_TRACE_MEMORY(addr, physaddr, res, 0, 0); // MJR
     }
     return res;
 }
@@ -232,7 +232,7 @@ glue(glue(glue(CPU_PREFIX, lds), SUFFIX), MEMSUFFIX)(ENV_PARAM
 #endif
             res = glue(glue(lds, SUFFIX), _raw)((uint8_t *)physaddr);
 
-        S2E_TRACE_MEMORY(addr, physaddr, res, 0, 0);
+        // S2E_TRACE_MEMORY(addr, physaddr, res, 0, 0); // MJR
     }
     return res;
 }
@@ -272,7 +272,7 @@ glue(glue(glue(CPU_PREFIX, st), SUFFIX), MEMSUFFIX)(ENV_PARAM target_ulong ptr,
 #endif
             glue(glue(st, SUFFIX), _raw)((uint8_t *)physaddr, v);
 
-        S2E_TRACE_MEMORY(addr, physaddr, v, 1, 0);
+        // S2E_TRACE_MEMORY(addr, physaddr, v, 1, 0); // MJR
     }
 }
 
diff --git a/qemu/softmmu_template.h b/qemu/softmmu_template.h
index 1ebbdf5..1dedfca 100644
--- a/qemu/softmmu_template.h
+++ b/qemu/softmmu_template.h
@@ -85,15 +85,21 @@
 #include <s2e/s2e_config.h>
 
 #ifdef S2E_LLVM_LIB
-#define S2E_TRACE_MEMORY(vaddr, haddr, value, isWrite, isIO) \
-    tcg_llvm_trace_memory_access(vaddr, haddr, \
-                                 value, 8*sizeof(value), isWrite, isIO);
+// MJR Changed definition of S2E_TRACE_MEMORY
+//#define S2E_TRACE_MEMORY(vaddr, haddr, value, isWrite, isIO)  \
+//    tcg_llvm_trace_memory_access(vaddr, haddr,                        \
+//                                 value, 8*sizeof(value), isWrite, isIO);
+#define S2E_TRACE_MEMORY(vaddr, value, isWrite) \
+    tcg_llvm_trace_memory_access(vaddr, value, sizeof(value), isWrite);
 #define S2E_FORK_AND_CONCRETIZE(val, max) \
     tcg_llvm_fork_and_concretize(val, 0, max)
 #else // S2E_LLVM_LIB
-#define S2E_TRACE_MEMORY(vaddr, haddr, value, isWrite, isIO) \
-    s2e_trace_memory_access(vaddr, haddr, \
-                            (uint8_t*) &value, sizeof(value), isWrite, isIO);
+// MJR Changed definition of S2E_TRACE_MEMORY
+//#define S2E_TRACE_MEMORY(vaddr, haddr, value, isWrite, isIO)  \
+//    s2e_trace_memory_access(vaddr, haddr,                             \
+//                            (uint8_t*) &value, sizeof(value), isWrite, isIO);
+#define S2E_TRACE_MEMORY(vaddr, value, isWrite) \
+    s2e_trace_memory_access(g_s2e, g_s2e_state, vaddr, (uint8_t*) &value, sizeof(value), isWrite);
 #define S2E_FORK_AND_CONCRETIZE(val, max) (val)
 #endif // S2E_LLVM_LIB
 
@@ -137,9 +143,27 @@ DATA_TYPE glue(glue(io_read, SUFFIX), MMUSUFFIX)(ENV_PARAM
     physaddr = (physaddr & TARGET_PAGE_MASK) + addr;
 
 #ifdef CONFIG_S2E
+/*
+  MJR
     if (glue(s2e_is_mmio_symbolic_, SUFFIX)(physaddr)) {
         s2e_switch_to_symbolic(g_s2e, g_s2e_state);
     }
+*/
+    // Only switch to symbolic if we're actually looking at
+    // doing a symbolic I/O memory operation
+    // OR DMA.  The second condition is for DMA, the first is for I/O memory.
+    if (s2e_issymfunc(mr, addr) || glue(s2e_is_mmio_symbolic_, SUFFIX)(physaddr)) {
+        // On this branch, we're accessing symbolic memory
+        // MJR
+        //target_phys_addr_t MJR_physaddr;
+        // This command gives us the address of the base of the page
+        //MJR_physaddr = cpu_cpu_x86_handle_mmu_fget_phys_page_debug(env, addr);
+        // Add the offset.
+        //MJR_physaddr += addr & (~TARGET_PAGE_MASK);
+        //if (glue(s2e_is_mmio_symbolic_, SUFFIX)(MJR_physaddr)) { // MJR
+        //If at least one byte is symbolic, generate a label
+        s2e_switch_to_symbolic(g_s2e, g_s2e_state);
+    }
 #endif
 
     env->mem_io_pc = (uintptr_t)retaddr;
@@ -165,6 +189,7 @@ DATA_TYPE glue(glue(io_read, SUFFIX), MMUSUFFIX)(ENV_PARAM
     return res;
 }
 
+// MJR: this function executes natively:
 inline DATA_TYPE glue(glue(io_read_chk, SUFFIX), MMUSUFFIX)(ENV_PARAM target_phys_addr_t physaddr,
                                           target_ulong addr,
                                           void *retaddr)
@@ -175,99 +200,135 @@ inline DATA_TYPE glue(glue(io_read_chk, SUFFIX), MMUSUFFIX)(ENV_PARAM target_phy
 
 #elif defined(S2E_LLVM_LIB) //S2E_LLVM_LIB
 
-inline DATA_TYPE glue(io_make_symbolic, SUFFIX)(const char *name) {
-    uint8_t ret;
-    klee_make_symbolic(&ret, sizeof(ret), name);
-    return ret;
-}
-
-
-inline DATA_TYPE glue(io_read_chk_symb_, SUFFIX)(const char *label, target_ulong physaddr, uintptr_t pa)
-{
-    union {
-        DATA_TYPE dt;
-        uint8_t arr[1<<SHIFT];
-    }data;
-    unsigned i;
-
-    data.dt = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa));
-
-    for (i = 0; i<(1<<SHIFT); ++i) {
-        if (s2e_is_mmio_symbolic_b(physaddr + i)) {
-            data.arr[i] = glue(io_make_symbolic, SUFFIX)(label);
-        }
-    }
-    return data.dt;
-}
-
-inline DATA_TYPE glue(glue(io_read_chk, SUFFIX), MMUSUFFIX)(ENV_PARAM target_phys_addr_t physaddr,
-                                          target_ulong addr,
-                                          void *retaddr)
-{
-    DATA_TYPE res;
-    target_phys_addr_t origaddr = physaddr;
-    MemoryRegion *mr = iotlb_to_region(physaddr);
 
-    target_ulong naddr = (physaddr & TARGET_PAGE_MASK)+addr;
-    char label[64];
-    int isSymb = 0;
-    if ((isSymb = glue(s2e_is_mmio_symbolic_, SUFFIX)(naddr))) {
-        //If at least one byte is symbolic, generate a label
-        trace_port(label, "iommuread_", naddr, env->eip);
-    }
-
-    //If it is not DMA, then check if it is normal memory
-    env->mem_io_pc = (uintptr_t)retaddr;
-    if (mr != &io_mem_ram && mr != &io_mem_rom
-        && mr != &io_mem_unassigned
-        && mr != &io_mem_notdirty
-            && !can_do_io(env)) {
-        cpu_io_recompile(env, retaddr);
-    }
-
-    env->mem_io_vaddr = addr;
-#if SHIFT <= 2
-    if (s2e_ismemfunc(mr, 0)) {
-        uintptr_t pa = s2e_notdirty_mem_write(physaddr);
-        if (isSymb) {
-            return glue(io_read_chk_symb_, SUFFIX)(ENV_VAR label, naddr, (uintptr_t)(pa));
-        }
-        res = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa));
-        return res;
-    }
-#else
-#ifdef TARGET_WORDS_BIGENDIAN
-    if (s2e_ismemfunc(mr, 0)) {
-        uintptr_t pa = s2e_notdirty_mem_write(physaddr);
-
-        if (isSymb) {
-            res = glue(io_read_chk_symb_, SUFFIX)(label, naddr, (uintptr_t)(pa)) << 32;
-            res |= glue(io_read_chk_symb_, SUFFIX)(label, naddr,(uintptr_t)(pa+4));
-        }else {
-            res = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa)) << 32;
-            res |= glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa+4));
-        }
-
-        return res;
-    }
-#else
-    if (s2e_ismemfunc(mr, 0)) {
-        uintptr_t pa = s2e_notdirty_mem_write(physaddr);
-        if (isSymb) {
-            res = glue(io_read_chk_symb_, SUFFIX)(label, naddr, (uintptr_t)(pa));
-            res |= glue(io_read_chk_symb_, SUFFIX)(label, naddr, (uintptr_t)(pa+4)) << 32;
-        }else {
-            res = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa));
-            res |= glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa + 4)) << 32;
-        }
-        return res;
-    }
-#endif
-#endif /* SHIFT > 2 */
 
-    //By default, call the original io_read function, which is external
-    return glue(glue(io_read, SUFFIX), MMUSUFFIX)(ENV_VAR origaddr, addr, retaddr);
-}
+/* // MJR: this function executes symbolically */
+/* inline DATA_TYPE glue(io_make_symbolic, SUFFIX)(const char *name) { */
+/*     uint8_t ret; */
+/*     klee_make_symbolic(&ret, sizeof(ret), name); */
+/*     return ret; */
+/* } */
+
+
+/* // MJR: this function executes symbolically */
+/* // MJR assumes physaddr is actually the physical address */
+/* inline DATA_TYPE glue(io_read_chk_symb_, SUFFIX)(const char *label, target_ulong addr, // MJR added addr */
+/*                                                  target_ulong physaddr, uintptr_t pa) */
+/* { */
+/*     union { */
+/*         DATA_TYPE dt; */
+/*         uint8_t arr[1<<SHIFT]; */
+/*     }data; */
+/*     unsigned i; */
+
+/*     data.dt = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa)); */
+
+/*     // MJR assume all this memory is symbolic */
+/*     for (i = 0; i<(1<<SHIFT); ++i) { */
+/*         // if (s2e_is_mmio_symbolic_b(physaddr + i)) { // MJR */
+/*         data.arr[i] = glue(io_make_symbolic, SUFFIX)(label); */
+/*         // } */
+/*     } */
+
+/*     // MJR added this but it does not work in S2E1.2: */
+/*     { */
+/*         unsigned int isWrite = 0; */
+/*         S2E_TRACE_MEMORY(addr, data.dt, isWrite); */
+/*     } */
+
+/*     return data.dt; */
+/* } */
+
+/* // MJR: this function executes symbolically */
+/* inline DATA_TYPE glue(glue(io_read_chk, SUFFIX), MMUSUFFIX)(ENV_PARAM target_phys_addr_t physaddr, */
+/*                                           target_ulong addr, */
+/*                                           void *retaddr) */
+/* { */
+/*     DATA_TYPE res; */
+/*     target_phys_addr_t origaddr = physaddr; */
+/*     MemoryRegion *mr = iotlb_to_region(physaddr); */
+
+/*     target_ulong naddr = (physaddr & TARGET_PAGE_MASK)+addr; */
+/*     char label[64]; */
+/*     int isSymb = 0; */
+
+/*     // MJR added this block: */
+/*     if (s2e_issymfunc(mr, addr)) */
+/*     { */
+/*         // This command gives us the address of the base of the page */
+/*         //MJR_physaddr = cpu_get_phys_page_debug(env, addr); */
+/*         // Add the offset. */
+/*         //MJR_physaddr += addr & (~TARGET_PAGE_MASK); */
+/*         isSymb = 1; */
+/*         //isSymb = glue(s2e_is_mmio_symbolic_, SUFFIX)(MJR_physaddr); */
+/*         //if (isSymb) { // MJR */
+/*         //If at least one byte is symbolic, generate a label */
+/*         // trace_port(label, "iommuread_", MJR_physaddr, env->eip); */
+/*         // trace_port(label, "iommuread_", physaddr, env->eip); // S2E 1.1 */
+/*         trace_port(label, "iommuread_", naddr, env->eip); // S2E 1.2 */
+/*     } */
+
+/* /\* */
+/*   MJR */
+/*     if ((isSymb = glue(s2e_is_mmio_symbolic_, SUFFIX)(naddr))) { */
+/*         //If at least one byte is symbolic, generate a label */
+/*         trace_port(label, "iommuread_", naddr, env->eip); */
+/*     } */
+/* *\/ */
+
+/*     //If it is not DMA, then check if it is normal memory */
+/*     env->mem_io_pc = (uintptr_t)retaddr; */
+/*     if (mr != &io_mem_ram && mr != &io_mem_rom */
+/*         && mr != &io_mem_unassigned */
+/*         && mr != &io_mem_notdirty */
+/*             && !can_do_io(env)) { */
+/*         cpu_io_recompile(env, retaddr); */
+/*     } */
+
+/*     env->mem_io_vaddr = addr; */
+/* #if SHIFT <= 2 */
+/* //    if (s2e_ismemfunc(mr, 0)) { // MJR */
+/*     uintptr_t pa = s2e_notdirty_mem_write(physaddr); // MJR */
+/*     if (isSymb) { // MJR */
+/*         return glue(io_read_chk_symb_, SUFFIX)(ENV_VAR label, addr, naddr, (uintptr_t)(pa)); */
+/*     } */
+/*     res = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa)); */
+/*     return res; */
+/* #else */
+/* #ifdef TARGET_WORDS_BIGENDIAN */
+/* //    if (s2e_ismemfunc(mr, 0)) { // MJR */
+/*     if (isSymb) { // MJR */
+/*         uintptr_t pa = s2e_notdirty_mem_write(physaddr); */
+
+/*         if (isSymb) { */
+/*             res = glue(io_read_chk_symb_, SUFFIX)(label, addr, naddr, (uintptr_t)(pa)) << 32; */
+/*             res |= glue(io_read_chk_symb_, SUFFIX)(label, addr, naddr,(uintptr_t)(pa+4)); */
+/*         }else { */
+/*             res = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa)) << 32; */
+/*             res |= glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa+4)); */
+/*         } */
+
+/*         return res; */
+/*     } */
+/* #else */
+/* //    if (s2e_ismemfunc(mr, 0)) { // MJR */
+/*     if (isSymb) { // MJR */
+/*         uintptr_t pa = s2e_notdirty_mem_write(physaddr); */
+/*         if (isSymb) { */
+/*             res = glue(io_read_chk_symb_, SUFFIX)(label, addr, naddr, (uintptr_t)(pa)); */
+/*             res |= glue(io_read_chk_symb_, SUFFIX)(label, addr, naddr, (uintptr_t)(pa+4)) << 32; */
+/*         }else { */
+/*             res = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa)); */
+/*             res |= glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(pa + 4)) << 32; */
+/*         } */
+/*         return res; */
+/*     } */
+/* #endif */
+/* #endif /\* SHIFT > 2 *\/ */
+
+/*     //By default, call the original io_read function, which is external */
+/*     return glue(glue(io_read, SUFFIX), MMUSUFFIX)(ENV_VAR origaddr, addr, retaddr); */
+/* } */
 
 
 #endif
@@ -303,7 +364,7 @@ glue(glue(glue(HELPER_PREFIX, ld), SUFFIX), MMUSUFFIX)(ENV_PARAM
             ioaddr = env->iotlb[mmu_idx][index];
             res = glue(glue(io_read_chk, SUFFIX), MMUSUFFIX)(ENV_VAR ioaddr, addr, retaddr);
 
-            S2E_TRACE_MEMORY(addr, addr+ioaddr, res, 0, 1);
+            // S2E_TRACE_MEMORY(addr, addr+ioaddr, res, 0, 1); // MJR
 
         } else if (unlikely(((addr & ~S2E_RAM_OBJECT_MASK) + DATA_SIZE - 1) >= S2E_RAM_OBJECT_SIZE)) {
             /* slow unaligned access (it spans two pages or IO) */
@@ -336,7 +397,7 @@ glue(glue(glue(HELPER_PREFIX, ld), SUFFIX), MMUSUFFIX)(ENV_PARAM
 #endif
                 res = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(addr+addend));
 
-            S2E_TRACE_MEMORY(addr, addr+addend, res, 0, 0);
+            // S2E_TRACE_MEMORY(addr, addr+addend, res, 0, 0); // MJR
         }
     } else {
         /* the page is not in the TLB : fill it */
@@ -381,7 +442,7 @@ glue(glue(slow_ld, SUFFIX), MMUSUFFIX)(ENV_PARAM
             ioaddr = env->iotlb[mmu_idx][index];
             res = glue(glue(io_read_chk, SUFFIX), MMUSUFFIX)(ENV_VAR ioaddr, addr, retaddr);
 
-            S2E_TRACE_MEMORY(addr, addr+ioaddr, res, 0, 1);
+            // S2E_TRACE_MEMORY(addr, addr+ioaddr, res, 0, 1); // MJR
         } else if (((addr & ~S2E_RAM_OBJECT_MASK) + DATA_SIZE - 1) >= S2E_RAM_OBJECT_SIZE) {
 
         do_unaligned_access:
@@ -411,7 +472,7 @@ glue(glue(slow_ld, SUFFIX), MMUSUFFIX)(ENV_PARAM
 #endif
                 res = glue(glue(ld, USUFFIX), _raw)((uint8_t *)(intptr_t)(addr+addend));
 
-            S2E_TRACE_MEMORY(addr, addr+addend, res, 0, 0);
+            // S2E_TRACE_MEMORY(addr, addr+addend, res, 0, 0); // MJR
         }
     } else {
         /* the page is not in the TLB : fill it */
@@ -439,7 +500,7 @@ void glue(glue(io_write, SUFFIX), MMUSUFFIX)(
                                           void *retaddr);
 #ifndef S2E_LLVM_LIB
 
-
+// MJR This function executes natively:
 void glue(glue(io_write, SUFFIX), MMUSUFFIX)(ENV_PARAM
                                              target_phys_addr_t physaddr,
                                           DATA_TYPE val,
@@ -448,6 +509,26 @@ void glue(glue(io_write, SUFFIX), MMUSUFFIX)(ENV_PARAM
 {
     MemoryRegion *mr = iotlb_to_region(physaddr);
 
+#ifdef CONFIG_S2E
+    // Only switch to symbolic if we're actually looking at
+    // doing a symbolic I/O memory operation.  Second condition is for DMA.
+    // This code should not run in symbolic mode
+    if (s2e_issymfunc(mr, addr) || glue(s2e_is_mmio_symbolic_, SUFFIX)(physaddr)) {
+        // On this branch, we're accessing symbolic memory
+        // MJR
+        //target_phys_addr_t MJR_physaddr;
+        // This command gives us the address of the base of the page
+        //MJR_physaddr = cpu_cpu_x86_handle_mmu_fget_phys_page_debug(env, addr);
+        // Add the offset.
+        //MJR_physaddr += addr & (~TARGET_PAGE_MASK);
+        //if (glue(s2e_is_mmio_symbolic_, SUFFIX)(MJR_physaddr)) { // MJR
+        //If at least one byte is symbolic, generate a label
+        if (g_tracing_enabled) {
+            s2e_switch_to_symbolic(g_s2e, g_s2e_state);
+        }
+    }
+#endif
+
     physaddr = (physaddr & TARGET_PAGE_MASK) + addr;
     if (mr != &io_mem_ram && mr != &io_mem_rom
         && mr != &io_mem_unassigned
@@ -483,6 +564,7 @@ inline void glue(glue(io_write_chk, SUFFIX), MMUSUFFIX)(ENV_PARAM target_phys_ad
 #else
 
 
+// MJR: this function executes symbolically
 /**
   * Only if compiling for LLVM.
   * This function checks whether a write goes to a clean memory page.
@@ -491,64 +573,77 @@ inline void glue(glue(io_write_chk, SUFFIX), MMUSUFFIX)(ENV_PARAM target_phys_ad
   *
   * It also deals with writes to memory-mapped devices that are symbolic
   */
-inline void glue(glue(io_write_chk, SUFFIX), MMUSUFFIX)(ENV_PARAM target_phys_addr_t physaddr,
-                                          DATA_TYPE val,
-                                          target_ulong addr,
-                                          void *retaddr)
-{
-    target_phys_addr_t origaddr = physaddr;
-    MemoryRegion *mr = iotlb_to_region(physaddr);
 
-    physaddr = (physaddr & TARGET_PAGE_MASK) + addr;
-    if (mr != &io_mem_ram && mr != &io_mem_rom
-        && mr != &io_mem_unassigned
-        && mr != &io_mem_notdirty
-            && !can_do_io(env)) {
-        cpu_io_recompile(env, retaddr);
-    }
-
-
-    env->mem_io_vaddr = addr;
-    env->mem_io_pc = (uintptr_t)retaddr;
-#if SHIFT <= 2
-    if (s2e_ismemfunc(mr, 1)) {
-        uintptr_t pa = s2e_notdirty_mem_write(physaddr);
-        glue(glue(st, SUFFIX), _raw)((uint8_t *)(intptr_t)(pa), val);
-        return;
-    }
-#else
-#ifdef TARGET_WORDS_BIGENDIAN
-    if (s2e_ismemfunc(s2e_ismemfunc(mr, 1)) {
-        uintptr_t pa = s2e_notdirty_mem_write(physaddr);
-        stl_raw((uint8_t *)(intptr_t)(pa), val>>32);
-        stl_raw((uint8_t *)(intptr_t)(pa+4), val);
-        return;
-    }
-#else
-    if (s2e_ismemfunc(mr, 1)) {
-        uintptr_t pa = s2e_notdirty_mem_write(physaddr);
-        stl_raw((uint8_t *)(intptr_t)(pa), val);
-        stl_raw((uint8_t *)(intptr_t)(pa+4), val>>32);
-        return;
-    }
-#endif
-#endif /* SHIFT > 2 */
-
-    //XXX: Check if MMIO is symbolic, and add corresponding trace entry
-
-    //Since we do not handle symbolic devices for now, we offer the
-    //option of concretizing the arguments to I/O helpers.
-    if (g_s2e_concretize_io_writes) {
-        val = klee_get_value(val);
-    }
-
-    if (g_s2e_concretize_io_addresses) {
-        addr = klee_get_value(addr);
-    }
-
-    //By default, call the original io_write function, which is external
-    glue(glue(io_write, SUFFIX), MMUSUFFIX)(ENV_VAR origaddr, val, addr, retaddr);
-}
+/* inline void glue(glue(io_write_chk, SUFFIX), MMUSUFFIX)(ENV_PARAM target_phys_addr_t physaddr, */
+/*                                           DATA_TYPE val, */
+/*                                           target_ulong addr, */
+/*                                           void *retaddr) */
+/* { */
+/*     target_phys_addr_t origaddr = physaddr; */
+/*     MemoryRegion *mr = iotlb_to_region(physaddr); */
+/*     int isSymb = 0; // MJR */
+
+/*     physaddr = (physaddr & TARGET_PAGE_MASK) + addr; */
+/*     if (mr != &io_mem_ram && mr != &io_mem_rom */
+/*         && mr != &io_mem_unassigned */
+/*         && mr != &io_mem_notdirty */
+/*             && !can_do_io(env)) { */
+/*         cpu_io_recompile(env, retaddr); */
+/*     } */
+
+
+/*     env->mem_io_vaddr = addr; */
+/*     env->mem_io_pc = (uintptr_t)retaddr; */
+
+/*     // MJR - added this block: */
+/*     if (s2e_issymfunc(mr, addr)) { */
+/*         unsigned int isWrite = 1; */
+/*         S2E_TRACE_MEMORY(addr, val, isWrite); */
+/*         isSymb = 1; */
+/*     } */
+
+/* #if SHIFT <= 2 */
+/*     // if (s2e_ismemfunc(mr, 1)) { // MJR */
+/*     if (isSymb) { // MJR */
+/*         uintptr_t pa = s2e_notdirty_mem_write(physaddr); */
+/*         glue(glue(st, SUFFIX), _raw)((uint8_t *)(intptr_t)(pa), val); */
+/*         return; */
+/*     } */
+/* #else */
+/* #ifdef TARGET_WORDS_BIGENDIAN */
+/*     // if (s2e_ismemfunc(s2e_ismemfunc(mr, 1)) { // MJR */
+/*     if (isSymb) { // MJR */
+/*         uintptr_t pa = s2e_notdirty_mem_write(physaddr); */
+/*         stl_raw((uint8_t *)(intptr_t)(pa), val>>32); */
+/*         stl_raw((uint8_t *)(intptr_t)(pa+4), val); */
+/*         return; */
+/*     } */
+/* #else */
+/*     // if (s2e_ismemfunc(mr, 1)) { // MJR */
+/*     if (isSymb) { // MJR */
+/*         uintptr_t pa = s2e_notdirty_mem_write(physaddr); */
+/*         stl_raw((uint8_t *)(intptr_t)(pa), val); */
+/*         stl_raw((uint8_t *)(intptr_t)(pa+4), val>>32); */
+/*         return; */
+/*     } */
+/* #endif */
+/* #endif /\* SHIFT > 2 *\/ */
+
+/*     //XXX: Check if MMIO is symbolic, and add corresponding trace entry */
+
+/*     //Since we do not handle symbolic devices for now, we offer the */
+/*     //option of concretizing the arguments to I/O helpers. */
+/*     if (g_s2e_concretize_io_writes) { */
+/*         val = klee_get_value(val); */
+/*     } */
+
+/*     if (g_s2e_concretize_io_addresses) { */
+/*         addr = klee_get_value(addr); */
+/*     } */
+
+/*     //By default, call the original io_write function, which is external */
+/*     glue(glue(io_write, SUFFIX), MMUSUFFIX)(ENV_VAR origaddr, val, addr, retaddr); */
+/* } */
 
 #endif
 
@@ -580,7 +675,7 @@ void glue(glue(glue(HELPER_PREFIX, st), SUFFIX), MMUSUFFIX)(ENV_PARAM
             ioaddr = env->iotlb[mmu_idx][index];
             glue(glue(io_write_chk, SUFFIX), MMUSUFFIX)(ENV_VAR ioaddr, val, addr, retaddr);
 
-            S2E_TRACE_MEMORY(addr, addr+ioaddr, val, 1, 1);
+            // S2E_TRACE_MEMORY(addr, addr+ioaddr, val, 1, 1); // MJR
         } else if (unlikely(((addr & ~S2E_RAM_OBJECT_MASK) + DATA_SIZE - 1) >= S2E_RAM_OBJECT_SIZE)) {
 
         do_unaligned_access:
@@ -604,6 +699,8 @@ void glue(glue(glue(HELPER_PREFIX, st), SUFFIX), MMUSUFFIX)(ENV_PARAM
 #endif
             addend = env->tlb_table[mmu_idx][index].addend;
 #if defined(CONFIG_S2E) && defined(S2E_ENABLE_S2E_TLB) && !defined(S2E_LLVM_LIB)
+            // MJR DMA write recording would take place here or in this immediate vicinity if we wanted it.
+            // DMA writes are not the same as I/O memory writes.
             S2ETLBEntry *e = &env->s2e_tlb_table[mmu_idx][object_index & (CPU_S2E_TLB_SIZE-1)];
             if(likely((e->addend & 1) && _s2e_check_concrete(e->objectState, addr & ~S2E_RAM_OBJECT_MASK, DATA_SIZE)))
                 glue(glue(st, SUFFIX), _p)((uint8_t*)(addr + (e->addend&~1)), val);
@@ -611,7 +708,7 @@ void glue(glue(glue(HELPER_PREFIX, st), SUFFIX), MMUSUFFIX)(ENV_PARAM
 #endif
                 glue(glue(st, SUFFIX), _raw)((uint8_t *)(intptr_t)(addr+addend), val);
 
-            S2E_TRACE_MEMORY(addr, addr+addend, val, 1, 0);
+            // S2E_TRACE_MEMORY(addr, addr+addend, val, 1, 0); // MJR
         }
     } else {
         /* the page is not in the TLB : fill it */
@@ -653,7 +750,7 @@ static void glue(glue(slow_st, SUFFIX), MMUSUFFIX)(ENV_PARAM
             ioaddr = env->iotlb[mmu_idx][index];
             glue(glue(io_write_chk, SUFFIX), MMUSUFFIX)(ENV_VAR ioaddr, val, addr, retaddr);
 
-            S2E_TRACE_MEMORY(addr, addr+ioaddr, val, 1, 1);
+            // S2E_TRACE_MEMORY(addr, addr+ioaddr, val, 1, 1); // MJR
         } else if (((addr & ~S2E_RAM_OBJECT_MASK) + DATA_SIZE - 1) >= S2E_RAM_OBJECT_SIZE) {
 
         do_unaligned_access:
@@ -683,7 +780,7 @@ static void glue(glue(slow_st, SUFFIX), MMUSUFFIX)(ENV_PARAM
 #endif
                 glue(glue(st, SUFFIX), _raw)((uint8_t *)(intptr_t)(addr+addend), val);
 
-            S2E_TRACE_MEMORY(addr, addr+addend, val, 1, 0);
+            // S2E_TRACE_MEMORY(addr, addr+addend, val, 1, 0); // MJR
         }
     } else {
         /* the page is not in the TLB : fill it */
diff --git a/qemu/target-i386/op_helper.c b/qemu/target-i386/op_helper.c
index 21502eb..4c31112 100644
--- a/qemu/target-i386/op_helper.c
+++ b/qemu/target-i386/op_helper.c
@@ -39,6 +39,10 @@
 #include "cpu-defs.h"
 #include "helper.h"
 
+#ifdef S2E_LLVM_LIB
+#include "s2e/s2e_qemu.h" // MJR
+#endif
+
 #if !defined(CONFIG_USER_ONLY)
 #include "softmmu_exec.h"
 #endif /* !defined(CONFIG_USER_ONLY) */
@@ -747,19 +751,27 @@ void helper_check_iol(uint32_t t0)
     check_io(t0, 4);
 }
 
-#ifdef S2E_LLVM_LIB
+#ifdef S2E_LLVM_LIB // MJR This code executes symbolically
 /**
  *  We bypass the call to the handlers in case of writes to symbolic ports to
  *  avoid concretizing data unnecessarily.
  */
 
+static uint32_t unique_id = 0; // MJR
+
 void helper_outb(uint32_t port, uint32_t data)
 {
+    if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) { // MJR added conditional
+        int size_in_bytes = 1; // MJR
+        int is_write = 1; // MJR
+        tcg_llvm_trace_port_access(port, data, size_in_bytes, is_write); // MJR
+    }
+
     if (g_s2e_concretize_io_addresses) {
         port = klee_get_value(port);
     }
 
-    tcg_llvm_trace_port_access(port, data, 8, 1);
+    // tcg_llvm_trace_port_access(port, data, 8, 1); // MJR
     if (!s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
         if (g_s2e_concretize_io_writes) {
             data = klee_get_value(data & 0xFF);
@@ -776,25 +788,35 @@ target_ulong helper_inb(uint32_t port)
     }
 
     if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
+        unique_id++; // MJR
+
         char label[64];
-        trace_port(label, "inb", port, env->eip);
-        uint8_t res = klee_int8(label);
-        tcg_llvm_trace_port_access(port, res, 8, 0);
+        trace_port(label, "inb", port, env->eip, unique_id);
+        uint8_t res = klee_int8(label); // MJR
+        int size_in_bytes = 1; // MJR
+        int is_write = 0; // MJR
+        s2e_establishIOMap (1, port, env->eip, unique_id); // MJR
+        tcg_llvm_trace_port_access(port, res, size_in_bytes, is_write); // MJR
         return res;
     }
-
     target_ulong res = cpu_inb(port);
-    tcg_llvm_trace_port_access(port, res, 8, 0);
+    // tcg_llvm_trace_port_access(port, res, 8, 0); // MJR removed
     return res;
 }
 
 void helper_outw(uint32_t port, uint32_t data)
 {
+    if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) { // MJR added conditional
+        int size_in_bytes = 2; // MJR
+        int is_write = 1; // MJR
+        tcg_llvm_trace_port_access(port, data, size_in_bytes, is_write); // MJR
+    }
+
     if (g_s2e_concretize_io_addresses) {
         port = klee_get_value(port);
     }
 
-    tcg_llvm_trace_port_access(port, data, 16, 1);
+    // tcg_llvm_trace_port_access(port, data, 16, 1); // MJR
     if (!s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
         if (g_s2e_concretize_io_writes) {
             data = klee_get_value(data & 0xFFFF);
@@ -811,24 +833,35 @@ target_ulong helper_inw(uint32_t port)
     }
 
     if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
+        unique_id++; // MJR
+
         char label[64];
-        trace_port(label, "inw", port, env->eip);
+        trace_port(label, "inw", port, env->eip, unique_id);
         uint16_t res = klee_int16(label);
-        tcg_llvm_trace_port_access(port, res, 16, 0);
+        int size_in_bytes = 2; // MJR
+        int is_write = 0; // MJR
+        s2e_establishIOMap (2, port, env->eip, unique_id); // MJR
+        tcg_llvm_trace_port_access(port, res, size_in_bytes, is_write); // MJR
         return res;
     }
     target_ulong res = cpu_inw(port);
-    tcg_llvm_trace_port_access(port, res, 16, 0);
+    // tcg_llvm_trace_port_access(port, res, 16, 0); // MJR removed
     return res;
 }
 
 void helper_outl(uint32_t port, uint32_t data)
 {
+    if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) { // MJR added conditional
+        int size_in_bytes = 4; // MJR
+        int is_write = 1; // MJR
+        tcg_llvm_trace_port_access(port, data, size_in_bytes, is_write); // MJR
+    }
+
     if (g_s2e_concretize_io_addresses) {
         port = klee_get_value(port);
     }
 
-    tcg_llvm_trace_port_access(port, data, 32, 1);
+    // tcg_llvm_trace_port_access(port, data, 32, 1); // MJR removed
     if (!s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
         if (g_s2e_concretize_io_writes) {
             data = klee_get_value(data);
@@ -845,25 +878,34 @@ target_ulong helper_inl(uint32_t port)
     }
 
     if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
+        unique_id++; // MJR
+
         char label[64];
-        trace_port(label, "inl", port, env->eip);
+        trace_port(label, "inl", port, env->eip, unique_id);
         uint32_t res = klee_int32(label);
-        tcg_llvm_trace_port_access(port, res, 32, 0);
+        int size_in_bytes = 4; // MJR
+        int is_write = 0; // MJR
+        s2e_establishIOMap (3, port, env->eip, unique_id); // MJR
+        tcg_llvm_trace_port_access(port, res, size_in_bytes, is_write); // MJR
         return res;
     }
     target_ulong res = cpu_inl(port);
-    tcg_llvm_trace_port_access(port, res, 32, 0);
+    // tcg_llvm_trace_port_access(port, res, 32, 0); // MJR removed
     return res;
 }
-#else
+#else // MJR this code executes natively
 
 void helper_outb(uint32_t port, uint32_t data)
 {
 #ifdef CONFIG_S2E
     if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
-        s2e_switch_to_symbolic(g_s2e, g_s2e_state);
+        int size_in_bytes = 1; // MJR
+        int is_write = 1;
+        s2e_trace_port_access(g_s2e, g_s2e_state, port, data & 0xff, size_in_bytes, is_write); // MJR Added 0xff
+        // s2e_switch_to_symbolic(g_s2e, g_s2e_state); // MJR
+        return; // MJR
     }
-    s2e_trace_port_access(g_s2e, g_s2e_state, port, data, 8, 1);
+    // s2e_trace_port_access(g_s2e, g_s2e_state, port, data, 8, 1); // MJR removed
 #endif
     cpu_outb(port, data & 0xff);
 }
@@ -872,13 +914,16 @@ target_ulong helper_inb(uint32_t port)
 {
 #ifdef CONFIG_S2E
     if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
+        // int size_in_bytes = 1; // MJR
+        // int is_write = 0; // MJR
+        // s2e_trace_port_access(g_s2e, g_s2e_state, port, 0, size_in_bytes, is_write); // MJR Removed
         s2e_switch_to_symbolic(g_s2e, g_s2e_state);
     }
 #endif
     target_ulong res = cpu_inb(port);
-#ifdef CONFIG_S2E
-    s2e_trace_port_access(g_s2e, g_s2e_state, port, res, 8, 0);
-#endif
+//#ifdef CONFIG_S2E
+//    s2e_trace_port_access(g_s2e, g_s2e_state, port, res, 8, 0); // MJR removed
+//#endif
     return res;
 }
 
@@ -886,9 +931,13 @@ void helper_outw(uint32_t port, uint32_t data)
 {
 #ifdef CONFIG_S2E
     if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
-        s2e_switch_to_symbolic(g_s2e, g_s2e_state);
+        int size_in_bytes = 2; // MJR
+        int is_write = 1; // MJR
+        s2e_trace_port_access(g_s2e, g_s2e_state, port, data & 0xffff, size_in_bytes, is_write); // MJR Added 0xffff
+        //s2e_switch_to_symbolic(g_s2e, g_s2e_state); // MJR
+        return; // MJR
     }
-    s2e_trace_port_access(g_s2e, g_s2e_state, port, data, 16, 1);
+    // s2e_trace_port_access(g_s2e, g_s2e_state, port, data, 16, 1); // MJR removed
 #endif
     cpu_outw(port, data & 0xffff);
 }
@@ -897,13 +946,16 @@ target_ulong helper_inw(uint32_t port)
 {
 #ifdef CONFIG_S2E
     if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
+        // int size_in_bytes = 2; // MJR
+        // int is_write = 0;
+        // s2e_trace_port_access(g_s2e, g_s2e_state, port, 0, size_in_bytes, is_write);  // MJR Removed
         s2e_switch_to_symbolic(g_s2e, g_s2e_state);
     }
 #endif
     target_ulong res = cpu_inw(port);
-#ifdef CONFIG_S2E
-    s2e_trace_port_access(g_s2e, g_s2e_state, port, res, 16, 0);
-#endif
+//#ifdef CONFIG_S2E
+//    s2e_trace_port_access(g_s2e, g_s2e_state, port, res, 16, 0); // MJR removed
+//#endif
     return res;
 }
 
@@ -911,9 +963,13 @@ void helper_outl(uint32_t port, uint32_t data)
 {
 #ifdef CONFIG_S2E
     if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
-        s2e_switch_to_symbolic(g_s2e, g_s2e_state);
+        int size_in_bytes = 4; // MJR
+        int is_write = 1; // MJR
+        s2e_trace_port_access(g_s2e, g_s2e_state, port, data, size_in_bytes, is_write); // MJR
+        //s2e_switch_t o_symbolic(g_s2e, g_s2e_state); // MJR
+        return; // MJR
     }
-    s2e_trace_port_access(g_s2e, g_s2e_state, port, data, 32, 1);
+    // s2e_trace_port_access(g_s2e, g_s2e_state, port, data, 32, 1); // MJR removed
 #endif
     cpu_outl(port, data);
 }
@@ -922,13 +978,16 @@ target_ulong helper_inl(uint32_t port)
 {
 #ifdef CONFIG_S2E
     if (s2e_is_port_symbolic(g_s2e, g_s2e_state, port)) {
+        // int size_in_bytes = 4; // MJR
+        // int is_write = 0;
+        // s2e_trace_port_access(g_s2e, g_s2e_state, port, 0, size_in_bytes, is_write);  // MJR Removed
         s2e_switch_to_symbolic(g_s2e, g_s2e_state);
     }
 #endif
     target_ulong res = cpu_inl(port);
-#ifdef CONFIG_S2E
-    s2e_trace_port_access(g_s2e, g_s2e_state, port, res, 32, 0);
-#endif
+//#ifdef CONFIG_S2E
+//    s2e_trace_port_access(g_s2e, g_s2e_state, port, res, 32, 0); // MJR removed
+//#endif
     return res;
 }
 
@@ -2335,7 +2394,7 @@ void helper_cmpxchg8b(target_ulong a0)
         eflags |= CC_Z;
     } else {
         /* always do the store */
-        stq(a0, d); 
+        stq(a0, d);
         EDX_W((uint32_t)(d >> 32));
         EAX_W((uint32_t)d);
         eflags &= ~CC_Z;
@@ -2360,8 +2419,8 @@ void helper_cmpxchg16b(target_ulong a0)
         eflags |= CC_Z;
     } else {
         /* always do the store */
-        stq(a0, d0); 
-        stq(a0 + 8, d1); 
+        stq(a0, d0);
+        stq(a0 + 8, d1);
         EDX = d1;
         EAX = d0;
         eflags &= ~CC_Z;
@@ -2760,7 +2819,7 @@ void helper_lcall_real(int new_cs, target_ulong new_eip1,
 }
 
 /* protected mode call */
-void helper_lcall_protected(int new_cs, target_ulong new_eip, 
+void helper_lcall_protected(int new_cs, target_ulong new_eip,
                             int shift, int next_eip_addend)
 {
     int new_stack, i;
@@ -3477,7 +3536,7 @@ void helper_rdpmc(void)
         raise_exception(EXCP0D_GPF);
     }
     helper_svm_check_intercept_param(SVM_EXIT_RDPMC, 0);
-    
+
     /* currently unimplemented */
     raise_exception_err(EXCP06_ILLOP, 0);
 }
@@ -4944,7 +5003,7 @@ void helper_fxsave(target_ulong ptr, int data64)
     if (data64) {
         stq(ptr + 0x08, 0); /* rip */
         stq(ptr + 0x10, 0); /* rdp */
-    } else 
+    } else
 #endif
     {
         stl(ptr + 0x08, 0); /* eip */
@@ -5206,7 +5265,7 @@ void helper_hlt(int next_eip_addend)
 {
     helper_svm_check_intercept_param(SVM_EXIT_HLT, 0);
     EIP += next_eip_addend;
-    
+
     do_hlt();
 }
 
@@ -5409,16 +5468,16 @@ void tlb_fill(CPUX86State *env1, target_ulong addr, target_ulong page_addr,
 #if defined(CONFIG_USER_ONLY)
 
 void helper_vmrun(int aflag, int next_eip_addend)
-{ 
+{
 }
-void helper_vmmcall(void) 
-{ 
+void helper_vmmcall(void)
+{
 }
 void helper_vmload(int aflag)
-{ 
+{
 }
 void helper_vmsave(int aflag)
-{ 
+{
 }
 void helper_stgi(void)
 {
@@ -5426,14 +5485,14 @@ void helper_stgi(void)
 void helper_clgi(void)
 {
 }
-void helper_skinit(void) 
-{ 
+void helper_skinit(void)
+{
 }
 void helper_invlpga(int aflag)
-{ 
+{
 }
-void helper_vmexit(uint32_t exit_code, uint64_t exit_info_1) 
-{ 
+void helper_vmexit(uint32_t exit_code, uint64_t exit_info_1)
+{
 }
 void helper_svm_check_intercept_param(uint32_t type, uint64_t param)
 {
@@ -5443,7 +5502,7 @@ void svm_check_intercept(CPUX86State *env1, uint32_t type)
 {
 }
 
-void helper_svm_check_io(uint32_t port, uint32_t param, 
+void helper_svm_check_io(uint32_t port, uint32_t param,
                          uint32_t next_eip_addend)
 {
 }
@@ -5452,16 +5511,16 @@ void helper_svm_check_io(uint32_t port, uint32_t param,
 static inline void svm_save_seg(target_phys_addr_t addr,
                                 const SegmentCache *sc)
 {
-    stw_phys(addr + offsetof(struct vmcb_seg, selector), 
+    stw_phys(addr + offsetof(struct vmcb_seg, selector),
              sc->selector);
-    stq_phys(addr + offsetof(struct vmcb_seg, base), 
+    stq_phys(addr + offsetof(struct vmcb_seg, base),
              sc->base);
-    stl_phys(addr + offsetof(struct vmcb_seg, limit), 
+    stl_phys(addr + offsetof(struct vmcb_seg, limit),
              sc->limit);
-    stw_phys(addr + offsetof(struct vmcb_seg, attrib), 
+    stw_phys(addr + offsetof(struct vmcb_seg, attrib),
              ((sc->flags >> 8) & 0xff) | ((sc->flags >> 12) & 0x0f00));
 }
-                                
+
 static inline void svm_load_seg(target_phys_addr_t addr, SegmentCache *sc)
 {
     unsigned int flags;
@@ -5473,7 +5532,7 @@ static inline void svm_load_seg(target_phys_addr_t addr, SegmentCache *sc)
     sc->flags = ((flags & 0xff) << 8) | ((flags & 0x0f00) << 12);
 }
 
-static inline void svm_load_seg_cache(target_phys_addr_t addr, 
+static inline void svm_load_seg_cache(target_phys_addr_t addr,
                                       CPUX86State *env, int seg_reg)
 {
     SegmentCache sc1, *sc = &sc1;
@@ -5516,13 +5575,13 @@ void helper_vmrun(int aflag, int next_eip_addend)
     stq_phys(env->vm_hsave + offsetof(struct vmcb, save.efer), env->efer);
     stq_phys(env->vm_hsave + offsetof(struct vmcb, save.rflags), compute_eflags());
 
-    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.es), 
+    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.es),
                   &env->segs[R_ES]);
-    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.cs), 
+    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.cs),
                  &env->segs[R_CS]);
-    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.ss), 
+    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.ss),
                  &env->segs[R_SS]);
-    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.ds), 
+    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.ds),
                  &env->segs[R_DS]);
 
     stq_phys(env->vm_hsave + offsetof(struct vmcb, save.rip),
@@ -5566,7 +5625,7 @@ void helper_vmrun(int aflag, int next_eip_addend)
             env->hflags2 |= HF2_HIF_MASK;
     }
 
-    cpu_load_efer(env, 
+    cpu_load_efer(env,
                   ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.efer)));
     env->mflags = 0;
     load_eflags(ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.rflags)),
@@ -5710,13 +5769,13 @@ void helper_vmsave(int aflag)
                 addr, ldq_phys(addr + offsetof(struct vmcb, save.fs.base)),
                 env->segs[R_FS].base);
 
-    svm_save_seg(addr + offsetof(struct vmcb, save.fs), 
+    svm_save_seg(addr + offsetof(struct vmcb, save.fs),
                  &env->segs[R_FS]);
-    svm_save_seg(addr + offsetof(struct vmcb, save.gs), 
+    svm_save_seg(addr + offsetof(struct vmcb, save.gs),
                  &env->segs[R_GS]);
-    svm_save_seg(addr + offsetof(struct vmcb, save.tr), 
+    svm_save_seg(addr + offsetof(struct vmcb, save.tr),
                  &env->tr);
-    svm_save_seg(addr + offsetof(struct vmcb, save.ldtr), 
+    svm_save_seg(addr + offsetof(struct vmcb, save.ldtr),
                  &env->ldt);
 
 #ifdef TARGET_X86_64
@@ -5754,7 +5813,7 @@ void helper_invlpga(int aflag)
 {
     target_ulong addr;
     helper_svm_check_intercept_param(SVM_EXIT_INVLPGA, 0);
-    
+
     if (aflag == 2)
         addr = EAX;
     else
@@ -5843,7 +5902,7 @@ void svm_check_intercept(CPUX86State *env1, uint32_t type)
     env = saved_env;
 }
 
-void helper_svm_check_io(uint32_t port, uint32_t param, 
+void helper_svm_check_io(uint32_t port, uint32_t param,
                          uint32_t next_eip_addend)
 {
     if (env->intercept & (1ULL << (SVM_EXIT_IOIO - SVM_EXIT_INTR))) {
@@ -5852,7 +5911,7 @@ void helper_svm_check_io(uint32_t port, uint32_t param,
         uint16_t mask = (1 << ((param >> 4) & 7)) - 1;
         if(lduw_phys(addr + port / 8) & (mask << (port & 7))) {
             /* next EIP */
-            stq_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2), 
+            stq_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2),
                      env->eip + next_eip_addend);
             helper_vmexit(SVM_EXIT_IOIO, param | (port << 16));
         }
@@ -5877,13 +5936,13 @@ void helper_vmexit(uint32_t exit_code, uint64_t exit_info_1)
     }
 
     /* Save the VM state in the vmcb */
-    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.es), 
+    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.es),
                  &env->segs[R_ES]);
-    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.cs), 
+    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.cs),
                  &env->segs[R_CS]);
-    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.ss), 
+    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.ss),
                  &env->segs[R_SS]);
-    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.ds), 
+    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.ds),
                  &env->segs[R_DS]);
 
     stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.gdtr.base), env->gdt.base);
@@ -5932,7 +5991,7 @@ void helper_vmexit(uint32_t exit_code, uint64_t exit_info_1)
     cpu_x86_update_cr3(env, ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.cr3)));
     /* we need to set the efer after the crs so the hidden flags get
        set properly */
-    cpu_load_efer(env, 
+    cpu_load_efer(env,
                   ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.efer)));
     env->mflags = 0;
     load_eflags(ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.rflags)),
diff --git a/qemu/tcg/tcg-llvm.cpp b/qemu/tcg/tcg-llvm.cpp
index a3d07e9..cf21f62 100644
--- a/qemu/tcg/tcg-llvm.cpp
+++ b/qemu/tcg/tcg-llvm.cpp
@@ -386,8 +386,8 @@ TCGLLVMContextPrivate::~TCGLLVMContextPrivate()
 #ifdef CONFIG_S2E
 void TCGLLVMContextPrivate::initializeHelpers()
 {
-    m_helperTraceMemoryAccess =
-            m_module->getFunction("tcg_llvm_trace_memory_access");
+//    m_helperTraceMemoryAccess = // MJR
+//            m_module->getFunction("tcg_llvm_trace_memory_access");
 
     m_helperTraceInstruction =
             m_module->getFunction("tcg_llvm_trace_instruction");
@@ -407,7 +407,7 @@ void TCGLLVMContextPrivate::initializeHelpers()
     m_qemu_st_helpers[3] = m_module->getFunction("__stq_mmu");
     m_qemu_st_helpers[4] = m_module->getFunction("__stq_mmu");
 
-    assert(m_helperTraceMemoryAccess);
+    // assert(m_helperTraceMemoryAccess); // MJR
     for(int i = 0; i < 5; ++i) {
         assert(m_qemu_ld_helpers[i]);
         assert(m_qemu_st_helpers[i]);
diff --git a/qemu/vl.c b/qemu/vl.c
index f4779ba..35fe915 100644
--- a/qemu/vl.c
+++ b/qemu/vl.c
@@ -2522,6 +2522,15 @@ int main(int argc, char **argv, char **envp)
               }
               break;
 
+            case QEMU_OPTION_fake_pci_cap_pm: // PM support
+              g_fake_pci.cap_pm = strtol(optarg, NULL, 0);
+              break;
+            case QEMU_OPTION_fake_pci_cap_msi: // MSI support
+              g_fake_pci.cap_msi = strtol(optarg, NULL, 0);
+              break;
+            case QEMU_OPTION_fake_pci_cap_pcie: // PCI-E support
+              g_fake_pci.cap_pcie = strtol(optarg, NULL, 0);
+              break;
 #endif
 
             case QEMU_OPTION_hda:
-- 
1.7.5.4

